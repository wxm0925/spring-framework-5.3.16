[[beans]]
= The IoC Container

本章介绍 Spring 的控制反转 （IoC） 容器。




[[beans-introduction]]
== Spring IoC 容器和 Bean 简介

本章介绍了Spring框架对控制反转（IoC）原则的实现。IoC也被称为依赖注入（DI）。这是一个过程中，对象通过构造函数参数、
工厂方法的参数或对象实例构建之后或从工厂方法返回后设置的属性来定义它们的依赖关系（即它们需要与之协作的其他对象）。
然后，容器在创建bean时注入这些依赖关系。这个过程本质上与bean本身通过直接创建类或使用服务定位器模式等机制
来控制其依赖关系的实例化或定位的过程相反（因此称为控制反转）。

`org.springframework.beans` 和 `org.springframework.context` 包是 Spring 框架 IoC 容器的基础。{api-spring-framework}/beans/factory/BeanFactory.html[`BeanFactory`] 接口提供了一种高级配置机制，能够管理任何类型的对象。{api-spring-framework}/context/ApplicationContext.html[`ApplicationContext`] 是 `BeanFactory` 的一个子接口，它增加了以下功能：

* 更容易与 Spring 的 AOP 特性集成
* 消息资源处理（用于国际化）
* 事件发布
* 应用层特定的上下文，如 `WebApplicationContext`，用于 Web 应用程序

简而言之，`BeanFactory` 提供了配置框架和基本功能，而 `ApplicationContext` 增加了更多面向企业的功能。`ApplicationContext` 是 `BeanFactory` 的完整超集，本章在描述 Spring 的 IoC 容器时，将仅使用 `ApplicationContext`。有关使用 `BeanFactory` 代替 `ApplicationContext` 的更多信息，请参见 <<beans-beanfactory>>。

在 Spring 中，由 Spring IoC 容器管理并构成应用程序骨干的对象被称为 bean。一个 bean 是由 Spring IoC 容器实例化、组装和管理的对象。否则，bean 仅仅是应用程序中的许多对象之一。bean 及其依赖关系通过容器使用的配置元数据反映出来。


[[beans-basics]]
== 容器概述

`org.springframework.context.ApplicationContext` 接口代表了 Spring IoC 容器，负责实例化、配置和组装 beans。容器通过读取配置元数据来获取有关实例化、配置和组装哪些对象的指令。配置元数据可以用 XML、Java 注解或 Java 代码来表示。它允许你表达构成应用程序的对象以及这些对象之间丰富的相互依赖关系。

Spring 提供了多个 `ApplicationContext` 接口的实现。在独立应用程序中，通常会创建
{api-spring-framework}/context/support/ClassPathXmlApplicationContext.html[`ClassPathXmlApplicationContext`] 或 {api-spring-framework}/context/support/FileSystemXmlApplicationContext.html[`FileSystemXmlApplicationContext`] 的实例。尽管 XML 一直是定义配置元数据的传统格式，你也可以通过提供少量的 XML 配置来声明性地启用对 Java 注解或代码作为元数据格式的支持，从而指示容器使用这些额外的元数据格式。

在大多数应用程序场景中，不需要显式用户代码来实例化一个或多个 Spring IoC 容器实例。例如，在 Web 应用程序场景中，应用程序的 `web.xml` 文件中简单的八行（或类似数量）样板 Web 描述符 XML 通常就足够了（参见 <<context-create>>）。如果使用 https://spring.io/tools[Spring Tools for Eclipse]（一个基于 Eclipse 的开发环境），你可以通过几次点击鼠标或按下几个键轻松创建这些样板配置。

下图显示了 Spring 如何工作的高级视图。你的应用程序类与配置元数据相结合，这样在 `ApplicationContext` 创建并初始化后，你就有了一个完全配置并可执行的系统或应用程序。

.The Spring IoC container
image::images/container-magic.png[]



[[beans-factory-metadata]]
=== 配置元数据

如上图所示，Spring IoC 容器使用一种配置元数据的形式。这种配置元数据代表了你作为应用程序开发人员告诉 Spring 容器如何实例化、配置和组装应用程序中的对象的方式。

传统上，配置元数据以简单直观的 XML 格式提供，本章的大部分内容也使用此格式来传达 Spring IoC 容器的关键概念和功能。

注意：基于 XML 的元数据并不是唯一允许的配置元数据形式。Spring IoC 容器本身与实际编写这些配置元数据的格式完全解耦。如今，许多开发人员选择 <<beans-java, 基于 Java 的配置>> 来配置他们的 Spring 应用程序。

有关使用其他形式的元数据与 Spring 容器配合的更多信息，请参见：

* <<beans-annotation-config, 基于注解的配置>>：Spring 2.5 引入了对基于注解配置元数据的支持。
* <<beans-java, 基于 Java 的配置>>：从 Spring 3.0 开始，Spring JavaConfig 项目提供的许多功能已成为 Spring 框架核心的一部分。因此，你可以使用 Java 而不是 XML 文件来定义应用程序类外部的 bean。要使用这些新特性，请参阅 https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html[`@Configuration`]、https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Bean.html[`@Bean`]、https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Import.html[`@Import`] 和 https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/DependsOn.html[`@DependsOn`] 注解。

Spring 配置至少包含一个并且通常包含多个容器需要管理的 bean 定义。基于 XML 的配置元数据将这些 beans 配置为顶级 `<beans/>` 元素内的 `<bean/>` 元素。Java 配置通常使用 `@Bean` 注解的方法位于 `@Configuration` 类中。

这些 bean 定义对应于构成应用程序的实际对象。通常，你定义服务层对象、数据访问对象（DAO）、表示对象（如 Struts 的 `Action` 实例）、基础设施对象（如 Hibernate 的 `SessionFactory`、JMS 的 `Queues` 等）。通常，不在容器中配置细粒度的领域对象，因为通常由 DAO 和业务逻辑负责创建和加载领域对象。但是，你可以使用 Spring 与 AspectJ 的集成来配置在 IoC 容器控制之外创建的对象。请参阅 <<aop-atconfigurable, 使用 AspectJ 在 Spring 中进行领域对象的依赖注入>>。

以下示例显示了基于 XML 的配置元数据的基本结构：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd">

		<bean id="..." class="..."> <1> <2>
			<!-- collaborators and configuration for this bean go here -->
		</bean>

		<bean id="..." class="...">
			<!-- collaborators and configuration for this bean go here -->
		</bean>

		<!-- more bean definitions go here -->

	</beans>
----

<1> `id` 属性是标识单个 bean 定义的字符串。

<2> `class` 属性定义了 bean 的类型，并使用全限定类名。

`id` 属性的值引用了协作对象。本示例未显示引用协作对象的 XML。有关更多信息，请参见 <<beans-dependencies,依赖关系>>。


[[beans-factory-instantiation]]
=== 实例化容器

提供给 `ApplicationContext` 构造函数的路径是资源字符串，它们让容器可以从各种外部资源中加载配置元数据，例如本地文件系统、Java `CLASSPATH` 等。

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");
----
.Kotlin
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
    val context = ClassPathXmlApplicationContext("services.xml", "daos.xml")
----

[NOTE]
====
在学习 Spring 的 IoC 容器之后，你可能会想了解更多关于 Spring 的 `Resource` 抽象（如 <<resources>> 中所述），它提供了一种方便的机制，用于从 URI 语法定义的位置读取 InputStream。特别是，`Resource` 路径用于构建应用程序上下文，如 <<resources-app-ctx>> 中所述。
====

以下示例展示了服务层对象 `(services.xml)` 的配置文件：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd">

		<!-- services -->

		<bean id="petStore" class="org.springframework.samples.jpetstore.services.PetStoreServiceImpl">
			<property name="accountDao" ref="accountDao"/>
			<property name="itemDao" ref="itemDao"/>
			<!-- 该 bean 的其他协作者和配置放在这里 -->
		</bean>

		<!-- 更多服务层 bean 定义放在这里 -->

	</beans>
----

以下示例展示了数据访问对象 `daos.xml` 的文件：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd">

		<bean id="accountDao"
			class="org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao">
			<!-- 该 bean 的其他协作者和配置放在这里 -->
		</bean>

		<bean id="itemDao" class="org.springframework.samples.jpetstore.dao.jpa.JpaItemDao">
			<!-- 该 bean 的其他协作者和配置放在这里 -->
		</bean>

		<!-- 更多数据访问对象的 bean 定义放在这里 -->

	</beans>
----

在上述示例中，服务层包括 `PetStoreServiceImpl` 类和两种数据访问对象 `JpaAccountDao` 和 `JpaItemDao`（基于 JPA 对象关系映射标准）。`property name` 元素指的是 JavaBean 属性的名称，`ref` 元素指的是另一个 bean 定义的名称。`id` 和 `ref` 元素之间的链接表达了协作对象之间的依赖关系。有关配置对象依赖关系的详细信息，请参见 <<beans-dependencies,Dependencies>>。


[[beans-factory-xml-import]]
==== 组合基于 XML 的配置元数据

将 bean 定义分布在多个 XML 文件中是有用的。通常，每个独立的 XML 配置文件代表了架构中的一个逻辑层或模块。

你可以使用应用程序上下文构造函数从所有这些 XML 片段中加载 bean 定义。此构造函数接受多个 `Resource` 位置，如 <<beans-factory-instantiation,前一节>> 所示。或者，可以使用一个或多个 `<import/>` 元素从另一个文件或多个文件中加载 bean 定义。以下示例展示了如何做到这一点：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<import resource="services.xml"/>
		<import resource="resources/messageSource.xml"/>
		<import resource="/resources/themeSource.xml"/>

		<bean id="bean1" class="..."/>
		<bean id="bean2" class="..."/>
	</beans>
----

在上述示例中，外部 bean 定义从三个文件中加载：`services.xml`、`messageSource.xml` 和 `themeSource.xml`。所有位置路径都是相对于导入文件的，因此 `services.xml` 必须位于与导入文件相同的目录或类路径位置，而 `messageSource.xml` 和 `themeSource.xml` 必须位于导入文件位置下的 `resources` 位置中。如你所见，前导斜杠会被忽略。然而，鉴于这些路径是相对的，最好不要使用斜杠。被导入的文件内容，包括顶级 `<beans/>` 元素，必须是符合 Spring Schema 的有效 XML bean 定义。

[NOTE]
====
可以使用相对 "../" 路径引用父目录中的文件，但不推荐这么做。这样做会创建对当前应用程序之外文件的依赖关系。特别是，这种引用不推荐用于 `classpath:` URL（例如，`classpath:../services.xml`），因为运行时解析过程会选择"最近的"类路径根目录，然后查看其父目录。类路径配置的更改可能会导致选择不同的、不正确的目录。

你可以始终使用完全限定的资源位置来代替相对路径：例如，`file:C:/config/services.xml` 或 `classpath:/config/services.xml`。然而，请注意，你的应用程序配置可能会耦合到特定的绝对位置。通常，最好保持这种绝对位置的间接引用——例如，通过 "${...}" 占位符，这些占位符在运行时通过 JVM 系统属性解析。
====

命名空间本身提供了导入指令功能。除了普通的 bean 定义之外，Spring 提供了一系列 XML 命名空间，以便进一步进行配置功能，例如 `context` 和 `util` 命名空间。


[[groovy-bean-definition-dsl]]
==== Groovy Bean Definition DSL

作为外部化配置元数据的进一步示例，bean 定义还可以用 Spring 的 Groovy Bean Definition DSL 表示，这种 DSL 在 Grails 框架中广为人知。通常，这种配置存在于“.groovy”文件中，其结构如下例所示：

[source,groovy,indent=0,subs="verbatim,quotes"]
----
	beans {
		dataSource(BasicDataSource) {
			driverClassName = "org.hsqldb.jdbcDriver"
			url = "jdbc:hsqldb:mem:grailsDB"
			username = "sa"
			password = ""
			settings = [mynew:"setting"]
		}
		sessionFactory(SessionFactory) {
			dataSource = dataSource
		}
		myService(MyService) {
			nestedBean = { AnotherBean bean ->
				dataSource = dataSource
			}
		}
	}
----

这种配置风格在很大程度上等同于 XML bean 定义，甚至支持 Spring 的 XML 配置命名空间。它还允许通过 `importBeans` 指令导入 XML bean 定义文件。


[[beans-factory-client]]
=== 使用容器

`ApplicationContext` 是一个高级工厂接口，能够维护不同 bean 及其依赖关系的注册表。通过使用 `T getBean(String name, Class<T> requiredType)` 方法，你可以检索你的 bean 实例。

`ApplicationContext` 允许你读取 bean 定义并访问它们，如下例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// 创建并配置 bean
	ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");

	// 检索配置的实例
	PetStoreService service = context.getBean("petStore", PetStoreService.class);

	// 使用配置的实例
	List<String> userList = service.getUsernameList();
----
.Kotlin
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
    import org.springframework.beans.factory.getBean

	// 创建并配置 bean
    val context = ClassPathXmlApplicationContext("services.xml", "daos.xml")

    // 检索配置的实例
    val service = context.getBean<PetStoreService>("petStore")

    // 使用配置的实例
    var userList = service.getUsernameList()
----

使用 Groovy 配置时，引导过程非常相似。它有一个不同的上下文实现类，该类支持 Groovy（但也理解 XML bean 定义）。以下示例展示了 Groovy 配置：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	ApplicationContext context = new GenericGroovyApplicationContext("services.groovy", "daos.groovy");
----
.Kotlin
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
val context = GenericGroovyApplicationContext("services.groovy", "daos.groovy")
----

最灵活的变体是 `GenericApplicationContext`，它与读取器委托结合使用——例如，对于 XML 文件使用 `XmlBeanDefinitionReader`，如下例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	GenericApplicationContext context = new GenericApplicationContext();
	new XmlBeanDefinitionReader(context).loadBeanDefinitions("services.xml", "daos.xml");
	context.refresh();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val context = GenericApplicationContext()
	XmlBeanDefinitionReader(context).loadBeanDefinitions("services.xml", "daos.xml")
	context.refresh()
----

你还可以对 Groovy 文件使用 `GroovyBeanDefinitionReader`，如下例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	GenericApplicationContext context = new GenericApplicationContext();
	new GroovyBeanDefinitionReader(context).loadBeanDefinitions("services.groovy", "daos.groovy");
	context.refresh();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val context = GenericApplicationContext()
	GroovyBeanDefinitionReader(context).loadBeanDefinitions("services.groovy", "daos.groovy")
	context.refresh()
----

你可以在同一个 `ApplicationContext` 中混合并匹配这些读取器委托，从不同的配置源读取 bean 定义。

然后，你可以使用 `getBean` 来检索你的 bean 实例。`ApplicationContext` 接口还有一些其他用于检索 bean 的方法，但理想情况下，你的应用程序代码不应使用它们。实际上，你的应用程序代码不应有任何对 `getBean()` 方法的调用，因此不应依赖于 Spring API。例如，Spring 与 Web 框架的集成为各种 Web 框架组件（如控制器和 JSF 管理的 bean）提供了依赖注入，允许你通过元数据（如自动装配注解）声明对特定 bean 的依赖关系。



[[beans-definition]]
== Bean 概述

Spring IoC 容器管理一个或多个 beans。这些 beans 是通过你提供给容器的配置元数据创建的（例如，以 XML `<bean/>` 定义的形式）。

在容器内部，这些 bean 定义被表示为 `BeanDefinition` 对象，其中包含（除了其他信息外）以下元数据：

* 包名限定的类名：通常是所定义的 bean 的实际实现类。
* Bean 的行为配置元素，声明该 bean 在容器中应如何表现（范围、生命周期回调等）。
* 其他 bean 的引用，这些引用是该 bean 完成其工作所需的。这些引用也被称为协作者或依赖。
* 在新创建的对象中设置的其他配置设置——例如，连接池管理 bean 中池的大小限制或连接数。

这些元数据被转换为构成每个 bean 定义的一组属性。下表描述了这些属性：

[[beans-factory-bean-definition-tbl]]
.Bean 定义
|===
| 属性| 解释在...

| 类
| <<beans-factory-class>>

| 名称
| <<beans-beanname>>

| 作用域
| <<beans-factory-scopes>>

| 构造函数参数
| <<beans-factory-collaborators>>

| 属性
| <<beans-factory-collaborators>>

| 自动装配模式
| <<beans-factory-autowire>>

| 延迟初始化模式
| <<beans-factory-lazy-init>>

| 初始化方法
| <<beans-factory-lifecycle-initializingbean>>

| 销毁方法
| <<beans-factory-lifecycle-disposablebean>>
|===

除了包含如何创建特定 bean 信息的 bean 定义外，`ApplicationContext` 实现还允许注册在容器外部（由用户）创建的现有对象。这是通过访问 `ApplicationContext` 的 `BeanFactory` 并调用 `getBeanFactory()` 方法来完成的，该方法返回 `BeanFactory` 的 `DefaultListableBeanFactory` 实现。`DefaultListableBeanFactory` 通过 `registerSingleton(..)` 和 `registerBeanDefinition(..)` 方法支持这种注册。然而，典型的应用程序仅通过常规的 bean 定义元数据工作。

[NOTE]
====
Bean 元数据和手动提供的单例实例需要尽早注册，以便容器在自动装配和其他自省步骤中能正确处理它们。尽管在某种程度上支持覆盖现有的元数据和现有的单例实例，但在运行时注册新 beans（与对工厂的实时访问并发）并未得到官方支持，可能会导致并发访问异常、bean 容器中的不一致状态或两者兼而有之。
====



[[beans-beanname]]
=== 命名 Beans

每个 bean 都有一个或多个标识符。这些标识符在托管该 bean 的容器内必须是唯一的。一个 bean 通常只有一个标识符。然而，如果需要多个标识符，额外的标识符可以被视为别名。

在基于 XML 的配置元数据中，可以使用 `id` 属性、`name` 属性或两者来指定 bean 标识符。`id` 属性允许你指定一个唯一的 id。按照惯例，这些名称是字母数字组合（如 `myBean`，`someService` 等），但它们也可以包含特殊字符。如果你想为该 bean 引入其他别名，还可以在 `name` 属性中指定它们，使用逗号（`,`）、分号（`;`）或空格分隔。历史上，在 Spring 3.1 之前的版本中，`id` 属性被定义为 `xsd:ID` 类型，这限制了可能的字符。从 3.1 开始，它被定义为 `xsd:string` 类型。注意，尽管 XML 解析器不再强制执行，容器仍然会强制 bean `id` 的唯一性。

你不必为 bean 提供 `name` 或 `id`。如果你没有明确提供 `name` 或 `id`，容器会为该 bean 生成一个唯一名称。然而，如果你希望通过 `ref` 元素或服务定位器风格的查找来按名称引用该 bean，则必须提供一个名称。未提供名称的动机与使用 <<beans-inner-beans,内联 beans>> 和 <<beans-factory-autowire,自动装配协作者>> 有关。

.Bean 命名惯例
****
命名 bean 时，惯例是使用标准的 Java 实例字段命名惯例。也就是说，bean 名称以小写字母开头，并使用驼峰命名法。此类名称的示例包括 `accountManager`，`accountService`，`userDao`，`loginController` 等等。

一致地命名 beans 可以使你的配置更易读、更容易理解。而且，如果你使用 Spring AOP，它有助于根据名称应用建议到一组相关的 bean。
****

注意：在类路径中进行组件扫描时，Spring 为未命名的组件生成 bean 名称，遵循前述规则：基本上，将简单类名的首字母小写。然而，在（不常见的）特殊情况下，当第一个和第二个字符都是大写字母时，将保留原始大小写。这与 `java.beans.Introspector.decapitalize` 定义的规则相同（Spring 在此使用该规则）。


[[beans-beanname-alias]]
==== 在 Bean 定义外为 Bean 设置别名

在 bean 定义本身中，可以通过使用 `id` 属性指定的最多一个名称和 `name` 属性中的任意数量的其他名称的组合，为该 bean 提供多个名称。这些名称可以作为同一个 bean 的等效别名，在某些情况下很有用，例如让应用程序中的每个组件通过使用特定于该组件的 bean 名称来引用一个通用依赖项。

然而，在 bean 实际定义的地方指定所有别名并不总是足够的。有时，希望为定义在其他地方的 bean 引入一个别名。这种情况通常发生在配置被分割到各个子系统中的大型系统中，每个子系统都有自己的一组对象定义。在基于 XML 的配置元数据中，可以使用 `<alias/>` 元素来完成此操作。以下示例显示了如何执行此操作：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<alias name="fromName" alias="toName"/>
----

在这种情况下，使用此别名定义后，同一个容器中名为 `fromName` 的 bean 也可以被称为 `toName`。

例如，子系统 A 的配置元数据可能通过名称 `subsystemA-dataSource` 来引用一个 DataSource。子系统 B 的配置元数据可能通过名称 `subsystemB-dataSource` 来引用一个 DataSource。在组合使用这两个子系统的主应用程序时，主应用程序通过名称 `myApp-dataSource` 来引用 DataSource。为了让所有三个名称都引用同一个对象，可以将以下别名定义添加到配置元数据中：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<alias name="myApp-dataSource" alias="subsystemA-dataSource"/>
	<alias name="myApp-dataSource" alias="subsystemB-dataSource"/>
----

现在，每个组件和主应用程序都可以通过一个唯一的名称引用 DataSource，并且保证不会与其他定义冲突（有效地创建了一个命名空间），但它们都引用同一个 bean。

.Java 配置
****
如果使用 Java 配置，可以使用 `@Bean` 注解来提供别名。详情请参阅 <<beans-java-bean-annotation>>。
****



[[beans-factory-class]]
=== 实例化 Beans

一个 bean 定义本质上是一个创建一个或多个对象的配方。当容器被请求时，它会查看命名 bean 的配方，并使用该 bean 定义所封装的配置元数据来创建（或获取）一个实际对象。

如果你使用基于 XML 的配置元数据，可以在 `<bean/>` 元素的 `class` 属性中指定要实例化的对象的类型（或类）。这个 `class` 属性（在内部，它是 `BeanDefinition` 实例上的 `Class` 属性）通常是必需的。（对于例外情况，请参阅 <<beans-factory-class-instance-factory-method>> 和 <<beans-child-bean-definitions>>。）你可以通过以下两种方式之一使用 `Class` 属性：

* 通常，指定要构建的 bean 类，容器通过反射调用其构造函数直接创建 bean，这有点类似于使用 `new` 操作符的 Java 代码。
* 在不常见的情况下，指定包含 `static` 工厂方法的实际类，容器调用该类的 `static` 工厂方法来创建 bean。`static` 工厂方法调用返回的对象类型可以是相同类，也可以是完全不同的类。

.嵌套类名称
****
如果你想为嵌套类配置 bean 定义，可以使用嵌套类的二进制名称或源名称。

例如，如果你在 `com.example` 包中有一个名为 `SomeThing` 的类，并且这个 `SomeThing` 类有一个 `static` 嵌套类叫做 `OtherThing`，它们可以用美元符号（`$`）或点（`.`）分隔。因此，bean 定义中 `class` 属性的值可以是 `com.example.SomeThing$OtherThing` 或 `com.example.SomeThing.OtherThing`。
****

[[beans-factory-class-ctor]]
==== 使用构造函数实例化

当你通过构造函数方法创建 bean 时，所有普通类都可以被 Spring 使用并与之兼容。也就是说，被开发的类不需要实现任何特定接口或以特定方式编写代码。只需指定 bean 类即可。然而，具体取决于你为该 bean 使用的 IoC 类型，你可能需要一个默认的（空）构造函数。

Spring IoC 容器几乎可以管理你希望它管理的任何类。它不仅限于管理真正的 JavaBeans。大多数 Spring 用户更喜欢实际的 JavaBeans，这些 JavaBeans 只有一个默认的（无参数）构造函数和符合容器中属性的适当的 setter 和 getter。你也可以在容器中使用更复杂的非 bean 风格的类。例如，如果你需要使用一个完全不遵循 JavaBean 规范的遗留连接池，Spring 也可以管理它。

使用基于 XML 的配置元数据，可以按如下方式指定 bean 类：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="exampleBean" class="examples.ExampleBean"/>

	<bean name="anotherExample" class="examples.ExampleBeanTwo"/>
----

有关向构造函数提供参数（如果需要）并在对象构建后设置对象实例属性的机制的详细信息，请参阅 <<beans-factory-collaborators,注入依赖>>。


[[beans-factory-class-static-factory-method]]
==== 使用静态工厂方法实例化

当定义一个通过静态工厂方法创建的 bean 时，使用 `class` 属性指定包含 `static` 工厂方法的类，并使用一个名为 `factory-method` 的属性指定工厂方法本身的名称。你应该能够调用此方法（可选参数将在后面描述），并返回一个活动对象，该对象随后将被视为通过构造函数创建的对象。此类 bean 定义的一个用途是调用遗留代码中的 `static` 工厂。

以下 bean 定义指定了通过调用工厂方法来创建 bean。定义没有指定返回对象的类型（类），仅指定了包含工厂方法的类。在此示例中，`createInstance()` 方法必须是静态方法。以下示例显示了如何指定工厂方法：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="clientService"
		class="examples.ClientService"
		factory-method="createInstance"/>
----

以下示例显示了与上述 bean 定义配合使用的类：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class ClientService {
		private static ClientService clientService = new ClientService();
		private ClientService() {}

		public static ClientService createInstance() {
			return clientService;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class ClientService private constructor() {
		companion object {
			private val clientService = ClientService()
			fun createInstance() = clientService
		}
	}
----

有关向工厂方法提供（可选）参数的机制以及在从工厂返回对象后设置对象实例属性的详细信息，请参阅 <<beans-factory-properties-detailed,依赖项和配置详细信息>>。

[[beans-factory-class-instance-factory-method]]
==== 使用实例工厂方法实例化

类似于通过 <<beans-factory-class-static-factory-method,静态工厂方法>> 实例化，使用实例工厂方法实例化是调用容器中现有 bean 的非静态方法来创建一个新 bean。要使用此机制，保留 `class` 属性为空，并在 `factory-bean` 属性中指定当前（或父级或祖先）容器中包含要调用的实例方法以创建对象的 bean 的名称。使用 `factory-method` 属性设置工厂方法本身的名称。以下示例显示了如何配置这样的 bean：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<!-- 包含名为 createInstance() 方法的工厂 bean -->
	<bean id="serviceLocator" class="examples.DefaultServiceLocator">
		<!-- 注入此定位器 bean 所需的任何依赖项 -->
	</bean>

	<!-- 通过工厂 bean 创建的 bean -->
	<bean id="clientService"
		factory-bean="serviceLocator"
		factory-method="createClientServiceInstance"/>
----

以下示例显示了相应的类：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class DefaultServiceLocator {

		private static ClientService clientService = new ClientServiceImpl();

		public ClientService createClientServiceInstance() {
			return clientService;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class DefaultServiceLocator {
		companion object {
			private val clientService = ClientServiceImpl()
		}
		fun createClientServiceInstance(): ClientService {
			return clientService
		}
	}
----

一个工厂类还可以包含多个工厂方法，如以下示例所示：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="serviceLocator" class="examples.DefaultServiceLocator">
		<!-- 注入此定位器 bean 所需的任何依赖项 -->
	</bean>

	<bean id="clientService"
		factory-bean="serviceLocator"
		factory-method="createClientServiceInstance"/>

	<bean id="accountService"
		factory-bean="serviceLocator"
		factory-method="createAccountServiceInstance"/>
----

以下示例显示了相应的类：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class DefaultServiceLocator {

		private static ClientService clientService = new ClientServiceImpl();

		private static AccountService accountService = new AccountServiceImpl();

		public ClientService createClientServiceInstance() {
			return clientService;
		}

		public AccountService createAccountServiceInstance() {
			return accountService;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class DefaultServiceLocator {
		companion object {
			private val clientService = ClientServiceImpl()
			private val accountService = AccountServiceImpl()
		}

		fun createClientServiceInstance(): ClientService {
			return clientService
		}

		fun createAccountServiceInstance(): AccountService {
			return accountService
		}
	}
----

这种方法表明，工厂 bean 本身可以通过依赖注入（DI）进行管理和配置。请参阅 <<beans-factory-properties-detailed,依赖项和配置详细信息>>。

注意：在 Spring 文档中，“工厂 bean”指的是在 Spring 容器中配置的 bean，通过 <<beans-factory-class-instance-factory-method,实例>> 或 <<beans-factory-class-static-factory-method,静态>> 工厂方法创建对象。相比之下，`FactoryBean`（注意大小写）指的是 Spring 特定的 <<beans-factory-extension-factorybean, `FactoryBean`>> 实现类。


[[beans-factory-type-determination]]
==== 确定 Bean 的运行时类型

确定特定 bean 的运行时类型并不简单。在 bean 元数据定义中指定的类仅是一个初始类引用，可能会与声明的工厂方法结合，或者是 `FactoryBean` 类，这可能导致 bean 的运行时类型不同，或者在实例级别工厂方法的情况下根本不设置（而是通过指定的 `factory-bean` 名称解析）。此外，AOP 代理可能会用基于接口的代理包装 bean 实例，从而限制对目标 bean 实际类型的暴露（仅限其实现的接口）。

查找特定 bean 的实际运行时类型的推荐方法是对指定的 bean 名称调用 `BeanFactory.getType`。此方法考虑了上述所有情况，并返回 `BeanFactory.getBean` 调用将返回的相同 bean 名称的对象类型。

[[beans-dependencies]]
== 依赖关系

一个典型的企业应用程序并不由单个对象（或用 Spring 术语来说，是单个 bean）组成。即使是最简单的应用程序也有一些对象，它们共同工作以呈现最终用户所看到的一致应用程序。下一节解释了如何从定义一组独立的 bean 定义到实现一个对象协作以实现目标的完整应用程序。

[[beans-factory-collaborators]]
=== 依赖注入

依赖注入（Dependency Injection, DI）是一个过程，其中对象仅通过构造函数参数、工厂方法参数或在对象构造后或从工厂方法返回后在对象实例上设置的属性来定义其依赖关系（即，它们所依赖的其他对象）。然后，容器在创建 bean 时注入这些依赖关系。此过程从根本上与 bean 本身通过直接构造类或使用服务定位器模式来控制其依赖关系的实例化或位置相反（因此得名“控制反转”）。

使用 DI 原则后，代码更加简洁，并且当对象被提供其依赖关系时，解耦更加有效。对象不会查找其依赖关系，也不知道依赖关系的位置或类。因此，当依赖关系是接口或抽象基类时，你的类更易于测试，这允许在单元测试中使用存根或模拟实现。

DI 存在两种主要变体：<<beans-constructor-injection,基于构造函数的依赖注入>> 和 <<beans-setter-injection,基于 setter 的依赖注入>>。

[[beans-constructor-injection]]
==== 基于构造函数的依赖注入

基于构造函数的 DI 是通过容器调用带有多个参数的构造函数来实现的，每个参数代表一个依赖关系。调用带有特定参数的 `static` 工厂方法来构造 bean 几乎是等效的，本节讨论将构造函数和 `static` 工厂方法的参数视为类似。以下示例显示了一个只能通过构造函数注入来依赖注入的类：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class SimpleMovieLister {

		// SimpleMovieLister 依赖于 MovieFinder
		private final MovieFinder movieFinder;

		// 一个构造函数，以便 Spring 容器可以注入 MovieFinder
		public SimpleMovieLister(MovieFinder movieFinder) {
			this.movieFinder = movieFinder;
		}

		// 实际使用注入的 MovieFinder 的业务逻辑省略...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// 一个构造函数，以便 Spring 容器可以注入 MovieFinder
	class SimpleMovieLister(private val movieFinder: MovieFinder) {
		// 实际使用注入的 MovieFinder 的业务逻辑省略...
	}
----

注意，这个类没有什么特别之处。它是一个 POJO，没有依赖于特定容器的接口、基类或注解。

[[beans-factory-ctor-arguments-resolution]]
===== 构造函数参数解析

构造函数参数解析匹配通过使用参数的类型来进行。如果 bean 定义的构造函数参数中不存在潜在的歧义，则在 bean 实例化时，按照在 bean 定义中定义的顺序提供这些参数。考虑以下类：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	package x.y;

	public class ThingOne {

		public ThingOne(ThingTwo thingTwo, ThingThree thingThree) {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	package x.y

	class ThingOne(thingTwo: ThingTwo, thingThree: ThingThree)
----

假设 `ThingTwo` 和 `ThingThree` 类没有继承关系，因此不存在潜在的歧义。因此，以下配置可以正常工作，你不需要在 `<constructor-arg/>` 元素中显式指定构造函数参数索引或类型。

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<bean id="beanOne" class="x.y.ThingOne">
			<constructor-arg ref="beanTwo"/>
			<constructor-arg ref="beanThree"/>
		</bean>

		<bean id="beanTwo" class="x.y.ThingTwo"/>

		<bean id="beanThree" class="x.y.ThingThree"/>
	</beans>
----

当引用另一个 bean 时，类型已知，并且可以进行匹配（如上述示例中所示）。当使用简单类型时，例如 `<value>true</value>`，Spring 无法确定值的类型，因此在没有帮助的情况下无法通过类型进行匹配。考虑以下类：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	package examples;

	public class ExampleBean {

		// 计算最终答案所需的年份数
		private final int years;

		// 生命、宇宙及一切的答案
		private final String ultimateAnswer;

		public ExampleBean(int years, String ultimateAnswer) {
			this.years = years;
			this.ultimateAnswer = ultimateAnswer;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	package examples

	class ExampleBean(
		private val years: Int, // 计算最终答案所需的年份数
		private val ultimateAnswer: String // 生命、宇宙及一切的答案
	)
----

.[[beans-factory-ctor-arguments-type]]构造函数参数类型匹配
--
在上述情况下，如果你使用 `type` 属性显式指定构造函数参数的类型，容器可以使用类型匹配简单类型，如下例所示：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="exampleBean" class="examples.ExampleBean">
		<constructor-arg type="int" value="7500000"/>
		<constructor-arg type="java.lang.String" value="42"/>
	</bean>
----
--

.[[beans-factory-ctor-arguments-index]]构造函数参数索引
--
你可以使用 `index` 属性显式指定构造函数参数的索引，如下例所示：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="exampleBean" class="examples.ExampleBean">
		<constructor-arg index="0" value="7500000"/>
		<constructor-arg index="1" value="42"/>
	</bean>
----

除了解决多个简单值的歧义外，指定索引还解决了构造函数具有相同类型的两个参数的歧义。

注意：索引是从 0 开始的。
--

.[[beans-factory-ctor-arguments-name]]构造函数参数名称
--
你还可以使用构造函数参数名称来解决值的歧义，如下例所示：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="exampleBean" class="examples.ExampleBean">
		<constructor-arg name="years" value="7500000"/>
		<constructor-arg name="ultimateAnswer" value="42"/>
	</bean>
----

请记住，为了使其开箱即用，你的代码必须启用调试标志进行编译，以便 Spring 可以从构造函数中查找参数名称。如果你不能或不希望启用调试标志编译代码，可以使用 https://download.oracle.com/javase/8/docs/api/java/beans/ConstructorProperties.html[@ConstructorProperties] JDK 注解来显式命名你的构造函数参数。示例类必须如下所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	package examples;

	public class ExampleBean {

		// 字段省略

		@ConstructorProperties({"years", "ultimateAnswer"})
		public ExampleBean(int years, String ultimateAnswer) {
			this.years = years;
			this.ultimateAnswer = ultimateAnswer;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	package examples

	class ExampleBean
	@ConstructorProperties("years", "ultimateAnswer")
	constructor(val years: Int, val ultimateAnswer: String)
----
--


[[beans-setter-injection]]
==== 基于 Setter 的依赖注入

基于 Setter 的 DI 是通过容器在调用无参构造函数或无参 `static` 工厂方法实例化你的 bean 后调用 setter 方法来实现的。

以下示例显示了一个只能通过纯 setter 注入进行依赖注入的类。此类是常规的 Java 类。它是一个 POJO，没有依赖于特定容器的接口、基类或注解。

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class SimpleMovieLister {

		// SimpleMovieLister 依赖于 MovieFinder
		private MovieFinder movieFinder;

		// 一个 setter 方法，以便 Spring 容器可以注入 MovieFinder
		public void setMovieFinder(MovieFinder movieFinder) {
			this.movieFinder = movieFinder;
		}

		// 实际使用注入的 MovieFinder 的业务逻辑省略...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
class SimpleMovieLister {

	// 一个延迟初始化的属性，以便 Spring 容器可以注入 MovieFinder
	lateinit var movieFinder: MovieFinder

	// 实际使用注入的 MovieFinder 的业务逻辑省略...
}
----

`ApplicationContext` 支持它管理的 beans 的基于构造函数和基于 setter 的 DI。它还支持在通过构造函数方法已经注入了一些依赖关系后进行基于 setter 的 DI。你可以将依赖关系配置为 `BeanDefinition` 的形式，并结合使用 `PropertyEditor` 实例将属性从一种格式转换为另一种格式。然而，大多数 Spring 用户不会直接（即以编程方式）处理这些类，而是使用 XML `bean` 定义、注解组件（即，带有 `@Component`、`@Controller` 等注解的类）或 Java 基于 `@Configuration` 类中的 `@Bean` 方法。这些来源然后在内部转换为 `BeanDefinition` 实例，并用于加载整个 Spring IoC 容器实例。


[[beans-constructor-vs-setter-injection]]
.构造函数注入还是 setter 注入？
****
由于可以混合使用构造函数注入和 setter 注入，经验法则是使用构造函数注入处理强制依赖关系，而使用 setter 方法或配置方法处理可选依赖关系。请注意，可以在 setter 方法上使用 <<beans-required-annotation, @Required>> 注解将属性设置为必需的依赖项；然而，带有程序验证的构造函数注入是更好的选择。

Spring 团队通常倡导使用构造函数注入，因为它允许你将应用程序组件实现为不可变对象，并确保必需的依赖关系不是 `null`。此外，构造函数注入的组件在返回给客户端（调用）代码时总是处于完全初始化的状态。附带说明一下，大量的构造函数参数通常是不良代码的迹象，暗示该类可能承担了过多的责任，应该进行重构，以更好地实现关注点分离。

Setter 注入主要应仅用于可以在类内部分配合理默认值的可选依赖项。否则，必须在代码的每个使用依赖项的地方执行非空检查。Setter 注入的一个好处是，setter 方法使得该类的对象能够在以后进行重新配置或重新注入。因此，<<integration.adoc#jmx,JMX MBeans>> 管理是 setter 注入的一个令人信服的用例。

使用最适合特定类的 DI 风格。有时，当处理第三方类且你没有源代码时，选择已为你做出。例如，如果第三方类没有公开任何 setter 方法，那么构造函数注入可能是唯一可用的 DI 形式。
****

[[beans-dependency-resolution]]
==== 依赖解析过程

容器执行 bean 依赖解析的过程如下：

* `ApplicationContext` 被创建并初始化，使用描述所有 bean 的配置元数据。配置元数据可以通过 XML、Java 代码或注解来指定。
* 对于每个 bean，其依赖关系以属性、构造函数参数或静态工厂方法的参数形式表达（如果你使用的是静态工厂方法而不是常规构造函数）。这些依赖关系在实际创建 bean 时被提供给 bean。
* 每个属性或构造函数参数要么是要设置的值的实际定义，要么是对容器中另一个 bean 的引用。
* 每个作为值的属性或构造函数参数都从其指定的格式转换为该属性或构造函数参数的实际类型。默认情况下，Spring 可以将以字符串格式提供的值转换为所有内置类型，例如 `int`、`long`、`String`、`boolean` 等等。

Spring 容器在创建容器时验证每个 bean 的配置。然而，bean 属性本身在实际创建 bean 之前不会被设置。单例作用域且设置为预实例化的 bean（默认情况下）在创建容器时被创建。作用域在 <<beans-factory-scopes>> 中定义。否则，bean 仅在请求时创建。创建一个 bean 可能会导致创建一个 bean 依赖图，因为该 bean 的依赖关系及其依赖关系的依赖关系（等等）被创建并分配。请注意，这些依赖关系中的解析不匹配可能会在稍后出现——即，在首次创建受影响的 bean 时出现。

.循环依赖
****
如果你主要使用构造函数注入，可能会创建一个无法解决的循环依赖场景。

例如：类 A 通过构造函数注入需要类 B 的实例，而类 B 通过构造函数注入需要类 A 的实例。如果你配置了 A 类和 B 类的 bean 互相注入，Spring IoC 容器会在运行时检测到此循环引用，并抛出 `BeanCurrentlyInCreationException`。

一种可能的解决方案是编辑某些类的源代码，以通过 setter 而不是构造函数进行配置。或者，避免构造函数注入，仅使用 setter 注入。换句话说，尽管不推荐，你可以通过 setter 注入配置循环依赖。

与典型情况（没有循环依赖）不同，A bean 和 B bean 之间的循环依赖迫使其中一个 bean 在自身完全初始化之前被注入到另一个 bean 中（经典的鸡生蛋还是蛋生鸡的情况）。
****

通常可以信任 Spring 来做正确的事情。它会在容器加载时检测配置问题，例如引用不存在的 bean 和循环依赖。Spring 尽可能晚地设置属性和解析依赖关系，即在实际创建 bean 时进行。这意味着正确加载的 Spring 容器可能在你请求对象时生成异常，如果在创建该对象或其某个依赖关系时出现问题——例如，bean 因为缺少或无效的属性而抛出异常。这种配置问题的潜在延迟可见性是 `ApplicationContext` 实现默认情况下预实例化单例 bean 的原因。以在实际需要这些 bean 之前创建它们为代价，你在创建 `ApplicationContext` 时发现配置问题，而不是更晚。你仍然可以覆盖此默认行为，使单例 bean 延迟初始化，而不是急切预实例化。

如果不存在循环依赖，当一个或多个协作 bean 被注入到依赖 bean 时，每个协作 bean 在被注入到依赖 bean 之前完全配置好。这意味着，如果 bean A 依赖于 bean B，Spring IoC 容器会在调用 bean A 的 setter 方法之前完全配置 bean B。换句话说，bean 被实例化（如果它不是预实例化的单例），其依赖关系被设置，并调用相关的生命周期方法（例如，<<beans-factory-lifecycle-initializingbean, 配置的初始化方法>> 或 <<beans-factory-lifecycle-initializingbean,InitializingBean 回调方法>>）。


[[beans-some-examples]]
==== 依赖注入示例

以下示例使用基于 XML 的配置元数据进行基于 setter 的 DI。Spring XML 配置文件的一小部分如下指定了一些 bean 定义：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="exampleBean" class="examples.ExampleBean">
		<!-- 使用嵌套 ref 元素的 setter 注入 -->
		<property name="beanOne">
			<ref bean="anotherExampleBean"/>
		</property>

		<!-- 使用更简洁的 ref 属性的 setter 注入 -->
		<property name="beanTwo" ref="yetAnotherBean"/>
		<property name="integerProperty" value="1"/>
	</bean>

	<bean id="anotherExampleBean" class="examples.AnotherBean"/>
	<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>
----

以下示例显示了相应的 `ExampleBean` 类：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class ExampleBean {

		private AnotherBean beanOne;

		private YetAnotherBean beanTwo;

		private int i;

		public void setBeanOne(AnotherBean beanOne) {
			this.beanOne = beanOne;
		}

		public void setBeanTwo(YetAnotherBean beanTwo) {
			this.beanTwo = beanTwo;
		}

		public void setIntegerProperty(int i) {
			this.i = i;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
class ExampleBean {
	lateinit var beanOne: AnotherBean
	lateinit var beanTwo: YetAnotherBean
	var i: Int = 0
}
----

在上述示例中，setter 被声明为与 XML 文件中指定的属性匹配。以下示例使用基于构造函数的 DI：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="exampleBean" class="examples.ExampleBean">
		<!-- 使用嵌套 ref 元素的构造函数注入 -->
		<constructor-arg>
			<ref bean="anotherExampleBean"/>
		</constructor-arg>

		<!-- 使用更简洁的 ref 属性的构造函数注入 -->
		<constructor-arg ref="yetAnotherBean"/>

		<constructor-arg type="int" value="1"/>
	</bean>

	<bean id="anotherExampleBean" class="examples.AnotherBean"/>
	<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>
----

以下示例显示了相应的 `ExampleBean` 类：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class ExampleBean {

		private AnotherBean beanOne;

		private YetAnotherBean beanTwo;

		private int i;

		public ExampleBean(
			AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {
			this.beanOne = anotherBean;
			this.beanTwo = yetAnotherBean;
			this.i = i;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
class ExampleBean(
		private val beanOne: AnotherBean,
		private val beanTwo: YetAnotherBean,
		private val i: Int)
----

在 bean 定义中指定的构造函数参数用作 `ExampleBean` 构造函数的参数。

现在考虑这个示例的一个变体，其中不使用构造函数，而是让 Spring 调用 `static` 工厂方法返回对象的实例：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="exampleBean" class="examples.ExampleBean" factory-method="createInstance">
		<constructor-arg ref="anotherExampleBean"/>
		<constructor-arg ref="yetAnotherBean"/>
		<constructor-arg value="1"/>
	</bean>

	<bean id="anotherExampleBean" class="examples.AnotherBean"/>
	<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>
----

以下示例显示了相应的 `ExampleBean` 类：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class ExampleBean {

		// 私有构造函数
		private ExampleBean(...) {
			...
		}

		// 静态工厂方法；此方法的参数可以
		// 视为返回的 bean 的依赖关系，
		// 无论这些参数实际上是如何使用的。
		public static ExampleBean createInstance (
			AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {

			ExampleBean eb = new ExampleBean (...);
			// 其他操作...
			return eb;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class ExampleBean private constructor() {
		companion object {
			// 静态工厂方法；此方法的参数可以
			// 视为返回的 bean 的依赖关系，
			// 无论这些参数实际上是如何使用的。
			fun createInstance(anotherBean: AnotherBean, yetAnotherBean: YetAnotherBean, i: Int): ExampleBean {
				val eb = ExampleBean (...)
				// 其他操作...
				return eb
			}
		}
	}
----

传递给 `static` 工厂方法的参数由 `<constructor-arg/>` 元素提供，完全像实际使用构造函数一样。工厂方法返回的类的类型不必与包含 `static` 工厂方法的类类型相同（尽管在此示例中，它是相同的）。实例（非静态）工厂方法可以以基本相同的方式使用（除了使用 `factory-bean` 属性而不是 `class` 属性），因此我们在此不讨论这些细节。

[[beans-factory-properties-detailed]]
=== 依赖项和配置详细信息

如 <<beans-factory-collaborators,前一节>> 所述，可以将 bean 属性和构造函数参数定义为对其他受管理的 bean（协作者）的引用，或者定义为内联值。Spring 的基于 XML 的配置元数据支持在其 `<property/>` 和 `<constructor-arg/>` 元素中使用子元素类型来实现此目的。



[[beans-value-element]]
==== 直接值（基本类型、字符串等）

`<property/>` 元素的 `value` 属性将属性或构造函数参数指定为可读的字符串表示。Spring 的 <<core-convert-ConversionService-API,转换服务>> 用于将这些值从 `String` 转换为属性或参数的实际类型。以下示例显示了设置各种值的方法：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
		<!-- 导致调用 setDriverClassName(String) -->
		<property name="driverClassName" value="com.mysql.jdbc.Driver"/>
		<property name="url" value="jdbc:mysql://localhost:3306/mydb"/>
		<property name="username" value="root"/>
		<property name="password" value="misterkaoli"/>
	</bean>
----

以下示例使用了 <<beans-p-namespace,p-namespace>> 以更加简洁的 XML 配置：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:p="http://www.springframework.org/schema/p"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd">

		<bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource"
			destroy-method="close"
			p:driverClassName="com.mysql.jdbc.Driver"
			p:url="jdbc:mysql://localhost:3306/mydb"
			p:username="root"
			p:password="misterkaoli"/>

	</beans>
----

上述 XML 更加简洁。然而，除非使用支持在创建 bean 定义时自动完成属性的 IDE（如 https://www.jetbrains.com/idea/[IntelliJ IDEA] 或 https://spring.io/tools[Spring Tools for Eclipse]），否则拼写错误是在运行时而不是设计时发现的。强烈推荐使用这种 IDE 辅助工具。

你还可以配置一个 `java.util.Properties` 实例，如下所示：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="mappings"
		class="org.springframework.context.support.PropertySourcesPlaceholderConfigurer">

		<!-- 类型为 java.util.Properties -->
		<property name="properties">
			<value>
				jdbc.driver.className=com.mysql.jdbc.Driver
				jdbc.url=jdbc:mysql://localhost:3306/mydb
			</value>
		</property>
	</bean>
----

Spring 容器通过使用 JavaBeans `PropertyEditor` 机制将 `<value/>` 元素中的文本转换为 `java.util.Properties` 实例。这是一个不错的快捷方式，也是少数几个 Spring 团队倾向于使用嵌套 `<value/>` 元素而非 `value` 属性风格的地方之一。

[[beans-idref-element]]
===== `idref` 元素

`idref` 元素只是将容器中另一个 bean 的 `id`（一个字符串值 - 不是引用）传递给 `<constructor-arg/>` 或 `<property/>` 元素的一种无错误方式。以下示例展示了如何使用它：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="theTargetBean" class="..."/>

	<bean id="theClientBean" class="...">
		<property name="targetName">
			<idref bean="theTargetBean"/>
		</property>
	</bean>
----

上述 bean 定义片段在运行时与以下片段完全等效：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="theTargetBean" class="..." />

	<bean id="client" class="...">
		<property name="targetName" value="theTargetBean"/>
	</bean>
----

第一种形式优于第二种形式，因为使用 `idref` 标签可以让容器在部署时验证被引用的命名 bean 是否确实存在。在第二种变体中，对 `client` bean 的 `targetName` 属性传递的值没有进行任何验证。当实际实例化 `client` bean 时，拼写错误才会被发现（很可能是致命的结果）。如果 `client` bean 是一个 <<beans-factory-scopes,原型>> bean，则这种拼写错误及其导致的异常可能会在容器部署很久之后才被发现。

注意：`idref` 元素上的 `local` 属性在 4.0 beans XSD 中不再支持，因为它不再比常规 `bean` 引用提供更大的价值。在升级到 4.0 模式时，请将现有的 `idref local` 引用更改为 `idref bean`。

在 <<aop-pfb-1,AOP 拦截器>> 的 `ProxyFactoryBean` bean 定义配置中，`<idref/>` 元素至少在 Spring 2.0 之前的版本中非常有价值。当你指定拦截器名称时，使用 `<idref/>` 元素可以防止拼写错误拦截器 ID。


[[beans-ref-element]]
==== 对其他 Beans 的引用（协作者）

`ref` 元素是 `<constructor-arg/>` 或 `<property/>` 定义元素中的最后一个元素。在这里，你可以将 bean 的指定属性值设置为对容器管理的另一个 bean（协作者）的引用。被引用的 bean 是要设置属性的 bean 的依赖项，并且在设置属性之前根据需要按需初始化（如果协作者是单例 bean，可能已经由容器初始化）。所有引用最终都是对另一个对象的引用。作用域和验证取决于你是否通过 `bean` 或 `parent` 属性指定其他对象的 ID 或名称。

通过 `<ref/>` 标签的 `bean` 属性指定目标 bean 是最通用的形式，允许创建对同一容器或父容器中任何 bean 的引用，无论它是否在同一个 XML 文件中。`bean` 属性的值可以与目标 bean 的 `id` 属性相同，也可以与目标 bean 的 `name` 属性中的某个值相同。以下示例显示了如何使用 `ref` 元素：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<ref bean="someBean"/>
----

通过 `parent` 属性指定目标 bean 会创建对当前容器的父容器中的 bean 的引用。`parent` 属性的值可以与目标 bean 的 `id` 属性相同，也可以与目标 bean 的 `name` 属性中的某个值相同。目标 bean 必须位于当前容器的父容器中。你应该主要在有容器层次结构并且希望使用与父 bean 同名的代理包装父容器中的现有 bean 时使用此 bean 引用变体。以下两个列表显示了如何使用 `parent` 属性：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<!-- 在父上下文中 -->
	<bean id="accountService" class="com.something.SimpleAccountService">
		<!-- 在此插入所需的依赖项 -->
	</bean>
----

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<!-- 在子（后代）上下文中 -->
	<bean id="accountService" <!-- bean 名称与父 bean 相同 -->
		class="org.springframework.aop.framework.ProxyFactoryBean">
		<property name="target">
			<ref parent="accountService"/> <!-- 注意我们如何引用父 bean -->
		</property>
		<!-- 在此插入其他配置和依赖项 -->
	</bean>
----

注意：`ref` 元素上的 `local` 属性在 4.0 beans XSD 中不再支持，因为它不再比常规 `bean` 引用提供更大的价值。在升级到 4.0 模式时，请将现有的 `ref local` 引用更改为 `ref bean`。

[[beans-inner-beans]]
==== 内联 Beans

`<property/>` 或 `<constructor-arg/>` 元素中的 `<bean/>` 元素定义了一个内联 bean，如下示例所示：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="outer" class="...">
		<!-- 不使用对目标 bean 的引用，而是直接内联定义目标 bean -->
		<property name="target">
			<bean class="com.example.Person"> <!-- 这是内联 bean -->
				<property name="name" value="Fiona Apple"/>
				<property name="age" value="25"/>
			</bean>
		</property>
	</bean>
----

内联 bean 定义不需要定义 ID 或名称。如果指定了，容器不会将其用作标识符。容器还会在创建时忽略 `scope` 标志，因为内联 bean 始终是匿名的，并且总是与外部 bean 一起创建。无法独立访问内联 bean，也无法将其注入到封闭 bean 之外的协作 bean 中。

作为一种边缘情况，可以从自定义作用域中接收销毁回调——例如，单例 bean 中包含的请求作用域内联 bean 的情况。内联 bean 实例的创建与其包含的 bean 绑定，但销毁回调允许它参与请求作用域的生命周期。这并不是一个常见的场景。内联 bean 通常只是共享其包含 bean 的作用域。

[[beans-collection-elements]]
==== 集合

`<list/>`、`<set/>`、`<map/>` 和 `<props/>` 元素分别设置 Java `Collection` 类型 `List`、`Set`、`Map` 和 `Properties` 的属性和参数。以下示例展示了如何使用它们：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="moreComplexObject" class="example.ComplexObject">
		<!-- 导致调用 setAdminEmails(java.util.Properties) -->
		<property name="adminEmails">
			<props>
				<prop key="administrator">administrator@example.org</prop>
				<prop key="support">support@example.org</prop>
				<prop key="development">development@example.org</prop>
			</props>
		</property>
		<!-- 导致调用 setSomeList(java.util.List) -->
		<property name="someList">
			<list>
				<value>一个列表元素后跟一个引用</value>
				<ref bean="myDataSource" />
			</list>
		</property>
		<!-- 导致调用 setSomeMap(java.util.Map) -->
		<property name="someMap">
			<map>
				<entry key="一个条目" value="只是一些字符串"/>
				<entry key="一个引用" value-ref="myDataSource"/>
			</map>
		</property>
		<!-- 导致调用 setSomeSet(java.util.Set) -->
		<property name="someSet">
			<set>
				<value>只是一些字符串</value>
				<ref bean="myDataSource" />
			</set>
		</property>
	</bean>
----

映射键或值的值，或集合值，也可以是以下任何一个元素：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	bean | ref | idref | list | set | map | props | value | null
----

[[beans-collection-elements-merging]]
===== 集合合并

Spring 容器还支持合并集合。应用程序开发人员可以定义父 `<list/>`、`<map/>`、`<set/>` 或 `<props/>` 元素，并让子 `<list/>`、`<map/>`、`<set/>` 或 `<props/>` 元素继承并覆盖父集合中的值。也就是说，子集合的值是父子集合元素合并的结果，子集合的元素覆盖父集合中指定的值。

本节讨论集合合并，涉及父子 bean 机制。对父子 bean 定义不熟悉的读者可能希望在继续之前阅读 <<beans-child-bean-definitions,相关章节>>。

以下示例演示了集合合并：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<bean id="parent" abstract="true" class="example.ComplexObject">
			<property name="adminEmails">
				<props>
					<prop key="administrator">administrator@example.com</prop>
					<prop key="support">support@example.com</prop>
				</props>
			</property>
		</bean>
		<bean id="child" parent="parent">
			<property name="adminEmails">
				<!-- 合并是在子集合定义中指定的 -->
				<props merge="true">
					<prop key="sales">sales@example.com</prop>
					<prop key="support">support@example.co.uk</prop>
				</props>
			</property>
		</bean>
	<beans>
----

注意 `child` bean 定义的 `adminEmails` 属性的 `<props/>` 元素上使用的 `merge=true` 属性。当容器解析并实例化 `child` bean 时，生成的实例将具有一个 `adminEmails` `Properties` 集合，该集合包含将子 `adminEmails` 集合与父 `adminEmails` 集合合并的结果。以下列表显示了结果：

[literal,subs="verbatim,quotes"]
----
administrator=administrator@example.com
sales=sales@example.com
support=support@example.co.uk
----

子 `Properties` 集合的值集继承了父 `<props/>` 中的所有属性元素，子级的 `support` 值覆盖了父集合中的值。

这种合并行为同样适用于 `<list/>`、`<map/>` 和 `<set/>` 集合类型。在 `<list/>` 元素的特定情况下，保留了与 `List` 集合类型相关的语义（即，值的 `ordered` 集合的概念）。父列表的值位于所有子列表值之前。在 `Map`、`Set` 和 `Properties` 集合类型的情况下，没有顺序。因此，容器内部使用的相关 `Map`、`Set` 和 `Properties` 实现类型没有顺序语义。


[[beans-collection-merge-limitations]]
===== 集合合并的限制

你不能合并不同类型的集合（例如 `Map` 和 `List`）。如果你尝试这样做，将抛出相应的 `Exception`。`merge` 属性必须在较低的、继承的子定义中指定。在父集合定义中指定 `merge` 属性是多余的，并且不会导致所需的合并结果。

[[beans-collection-elements-strongly-typed]]
===== 强类型集合

随着 Java 5 中泛型类型的引入，你可以使用强类型集合。也就是说，可以声明一个 `Collection` 类型，使其只能包含（例如）`String` 元素。如果使用 Spring 将强类型 `Collection` 依赖注入到 bean 中，可以利用 Spring 的类型转换支持，使强类型 `Collection` 实例的元素在添加到 `Collection` 之前被转换为适当的类型。以下 Java 类和 bean 定义显示了如何执行此操作：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class SomeClass {

		private Map<String, Float> accounts;

		public void setAccounts(Map<String, Float> accounts) {
			this.accounts = accounts;
		}
	}
----

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<bean id="something" class="x.y.SomeClass">
			<property name="accounts">
				<map>
					<entry key="one" value="9.99"/>
					<entry key="two" value="2.75"/>
					<entry key="six" value="3.99"/>
				</map>
			</property>
		</bean>
	</beans>
----

当准备将 `something` bean 的 `accounts` 属性进行注入时，可以通过反射获取强类型 `Map<String, Float>` 的元素类型的泛型信息。因此，Spring 的类型转换基础设施将这些值元素识别为 `Float` 类型，并将字符串值（`9.99`、`2.75` 和 `3.99`）转换为实际的 `Float` 类型。

[[beans-null-element]]
==== 空值和空字符串值

Spring 将属性等的空参数视为空 `String`。以下基于 XML 的配置元数据片段将 `email` 属性设置为空 `String` 值（""）。

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean class="ExampleBean">
		<property name="email" value=""/>
	</bean>
----

上述示例相当于以下 Java 代码：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	exampleBean.setEmail("");
----

`<null/>` 元素处理 `null` 值。以下示例展示了一个例子：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean class="ExampleBean">
		<property name="email">
			<null/>
		</property>
	</bean>
----

上述配置相当于以下 Java 代码：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	exampleBean.setEmail(null);
----

[[beans-p-namespace]]
==== 使用 p-namespace 的 XML 快捷方式

p-namespace 允许你使用 `bean` 元素的属性（而不是嵌套的 `<property/>` 元素）来描述你的属性值、协作 bean，或两者。

Spring 支持可扩展的配置格式 <<core.adoc#xsd-schemas,使用命名空间>>，它们基于 XML 模式定义。本章讨论的 `beans` 配置格式是在 XML 模式文档中定义的。然而，p-namespace 并未在 XSD 文件中定义，它仅存在于 Spring 的核心中。

以下示例显示了两个 XML 片段（第一个使用标准 XML 格式，第二个使用 p-namespace），它们得出的结果相同：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:p="http://www.springframework.org/schema/p"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd">

		<bean name="classic" class="com.example.ExampleBean">
			<property name="email" value="someone@somewhere.com"/>
		</bean>

		<bean name="p-namespace" class="com.example.ExampleBean"
			p:email="someone@somewhere.com"/>
	</beans>
----

该示例显示了 bean 定义中名为 `email` 的 p-namespace 属性。这告诉 Spring 包含一个属性声明。如前所述，p-namespace 没有模式定义，因此你可以将属性名称设置为属性名称。

下一个示例包括两个具有对另一个 bean 的引用的 bean 定义：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:p="http://www.springframework.org/schema/p"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd">

		<bean name="john-classic" class="com.example.Person">
			<property name="name" value="John Doe"/>
			<property name="spouse" ref="jane"/>
		</bean>

		<bean name="john-modern"
			class="com.example.Person"
			p:name="John Doe"
			p:spouse-ref="jane"/>

		<bean name="jane" class="com.example.Person">
			<property name="name" value="Jane Doe"/>
		</bean>
	</beans>
----

该示例不仅包括使用 p-namespace 的属性值，还使用了一种特殊格式来声明属性引用。第一个 bean 定义使用 `<property name="spouse" ref="jane"/>` 来创建从 `john` bean 到 `jane` bean 的引用，而第二个 bean 定义使用 `p:spouse-ref="jane"` 作为属性来做同样的事情。在这种情况下，`spouse` 是属性名称，而 `-ref` 部分表示这不是一个直接值，而是对另一个 bean 的引用。

注意：p-namespace 不如标准 XML 格式灵活。例如，声明属性引用的格式与以 `Ref` 结尾的属性发生冲突，而标准 XML 格式则不会。我们建议你仔细选择你的方法，并将其传达给你的团队成员，以避免在同一时间生成使用所有三种方法的 XML 文档。


[[beans-c-namespace]]
==== 使用 c-namespace 的 XML 快捷方式

类似于 <<beans-p-namespace>>，c-namespace 是在 Spring 3.1 中引入的，允许通过内联属性配置构造函数参数，而不是使用嵌套的 `constructor-arg` 元素。

以下示例使用 `c:` 命名空间执行与 <<beans-constructor-injection>> 中相同的操作：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:c="http://www.springframework.org/schema/c"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd">

		<bean id="beanTwo" class="x.y.ThingTwo"/>
		<bean id="beanThree" class="x.y.ThingThree"/>

		<!-- 传统声明，带有可选参数名称 -->
		<bean id="beanOne" class="x.y.ThingOne">
			<constructor-arg name="thingTwo" ref="beanTwo"/>
			<constructor-arg name="thingThree" ref="beanThree"/>
			<constructor-arg name="email" value="something@somewhere.com"/>
		</bean>

		<!-- 使用参数名称的 c-namespace 声明 -->
		<bean id="beanOne" class="x.y.ThingOne" c:thingTwo-ref="beanTwo"
			c:thingThree-ref="beanThree" c:email="something@somewhere.com"/>

	</beans>
----

`c:` 命名空间使用与 `p:` 命名空间相同的约定（bean 引用以 `-ref` 结尾）按名称设置构造函数参数。同样，尽管它没有在 XSD 模式中定义，但它需要在 XML 文件中声明（它存在于 Spring 核心内部）。

对于构造函数参数名称不可用的少数情况（通常是字节码在没有调试信息的情况下编译时），你可以使用参数索引作为后备，如下所示：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<!-- c-namespace 索引声明 -->
	<bean id="beanOne" class="x.y.ThingOne" c:_0-ref="beanTwo" c:_1-ref="beanThree"
		c:_2="something@somewhere.com"/>
----

注意：由于 XML 语法的限制，索引符号需要存在前导 `_`，因为 XML 属性名称不能以数字开头（尽管某些 IDE 允许这样做）。相应的索引符号也可用于 `<constructor-arg>` 元素，但不常用，因为通常声明的顺序已经足够。

在实践中，构造函数解析 <<beans-factory-ctor-arguments-resolution,机制>> 在匹配参数方面非常有效，因此除非确有必要，我们建议在整个配置中使用名称符号。

[[beans-compound-property-names]]
==== 复合属性名称

在设置 bean 属性时，只要路径的所有组件（最终属性名称除外）都不为 `null`，就可以使用复合或嵌套属性名称。考虑以下 bean 定义：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="something" class="things.ThingOne">
		<property name="fred.bob.sammy" value="123" />
	</bean>
----

`something` bean 具有一个 `fred` 属性，该属性具有一个 `bob` 属性，而 `bob` 属性又具有一个 `sammy` 属性，最终的 `sammy` 属性将被设置为 `123` 的值。为了使其工作，在构造 bean 后，`something` 的 `fred` 属性和 `fred` 的 `bob` 属性不得为 `null`。否则，将抛出 `NullPointerException`。

[[beans-factory-dependson]]
=== 使用 `depends-on`

如果一个 bean 是另一个 bean 的依赖项，通常意味着一个 bean 被设置为另一个 bean 的属性。通常，你通过 XML 配置元数据中的 <<beans-ref-element, `<ref/>` 元素>> 来实现这一点。然而，有时 bean 之间的依赖关系不那么直接。例如，当类中的静态初始化器需要被触发时，例如用于数据库驱动程序注册。`depends-on` 属性可以显式强制一个或多个 bean 在使用该元素的 bean 之前初始化。以下示例使用 `depends-on` 属性来表示对单个 bean 的依赖关系：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="beanOne" class="ExampleBean" depends-on="manager"/>
	<bean id="manager" class="ManagerBean" />
----

要表示对多个 bean 的依赖关系，请提供一个以 bean 名称为值的列表作为 `depends-on` 属性的值（逗号、空格和分号是有效的分隔符）：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="beanOne" class="ExampleBean" depends-on="manager,accountDao">
		<property name="manager" ref="manager" />
	</bean>

	<bean id="manager" class="ManagerBean" />
	<bean id="accountDao" class="x.y.jdbc.JdbcAccountDao" />
----

注意：`depends-on` 属性可以同时指定初始化时的依赖关系，并且在仅适用于 <<beans-factory-scopes-singleton,单例>> beans 的情况下，指定相应的销毁时依赖关系。定义了 `depends-on` 关系的依赖 bean 在给定 bean 本身被销毁之前首先被销毁。因此，`depends-on` 还可以控制关闭顺序。

[[beans-factory-lazy-init]]
=== 延迟初始化的 Beans

默认情况下，`ApplicationContext` 实现会在初始化过程中急切地创建和配置所有 <<beans-factory-scopes-singleton,单例>> bean。通常，这种预实例化是可取的，因为可以立即发现配置或周围环境中的错误，而不是在数小时甚至数天后发现。当这种行为不理想时，你可以通过将 bean 定义标记为延迟初始化来防止单例 bean 的预实例化。延迟初始化的 bean 告诉 IoC 容器在首次请求时创建 bean 实例，而不是在启动时创建。

在 XML 中，此行为由 `<bean/>` 元素上的 `lazy-init` 属性控制，如下例所示：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="lazy" class="com.something.ExpensiveToCreateBean" lazy-init="true"/>
	<bean name="not.lazy" class="com.something.AnotherBean"/>
----

当 `ApplicationContext` 消费上述配置时，`lazy` bean 在 `ApplicationContext` 启动时不会急切地预实例化，而 `not.lazy` bean 则会急切地预实例化。

然而，当延迟初始化的 bean 是非延迟初始化单例 bean 的依赖项时，`ApplicationContext` 会在启动时创建延迟初始化的 bean，因为它必须满足单例的依赖关系。延迟初始化的 bean 被注入到其他非延迟初始化的单例 bean 中。

你还可以通过在 `<beans/>` 元素上使用 `default-lazy-init` 属性在容器级别控制延迟初始化，如下例所示：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans default-lazy-init="true">
		<!-- 没有 bean 会被预实例化... -->
	</beans>
----



[[beans-factory-autowire]]
=== 自动装配协作者

Spring 容器可以在协作 bean 之间自动装配关系。你可以通过检查 `ApplicationContext` 的内容，让 Spring 自动为你的 bean 解析协作者（其他 bean）。自动装配具有以下优点：

* 自动装配可以显著减少指定属性或构造函数参数的需求。（其他机制，如在本章其他部分讨论的 bean 模板 <<beans-child-bean-definitions>>，在这方面也很有价值。）
* 自动装配可以在你的对象发展时更新配置。例如，如果你需要向类中添加依赖关系，该依赖关系可以自动满足，而不需要你修改配置。因此，自动装配在开发期间尤其有用，而不会否定当代码库变得更加稳定时切换到显式装配的选项。

当使用基于 XML 的配置元数据（参见 <<beans-factory-collaborators>>）时，可以通过 `<bean/>` 元素的 `autowire` 属性为 bean 定义指定自动装配模式。自动装配功能有四种模式。你可以为每个 bean 指定自动装配，从而选择要自动装配的 bean。下表描述了四种自动装配模式：

[[beans-factory-autowiring-modes-tbl]]
.自动装配模式
[cols="20%,80%"]
|===
| 模式| 说明

| `no`
| （默认）不自动装配。bean 引用必须由 `ref` 元素定义。对于大型部署，不建议更改默认设置，因为显式指定协作者可以提供更大的控制和清晰度。在某种程度上，它记录了系统的结构。

| `byName`
| 按属性名称自动装配。Spring 查找与需要自动装配的属性同名的 bean。例如，如果 bean 定义设置为按名称自动装配，并且它包含一个 `master` 属性（即，它具有一个 `setMaster(..)` 方法），Spring 会查找名为 `master` 的 bean 定义，并使用它来设置该属性。

| `byType`
| 如果容器中恰好存在一个属性类型的 bean，则允许该属性自动装配。如果存在多个，则会抛出致命异常，这表明不能对该 bean 使用 `byType` 自动装配。如果没有匹配的 bean，则不会发生任何事情（该属性不会被设置）。

| `constructor`
| 类似于 `byType`，但适用于构造函数参数。如果容器中没有恰好一个构造函数参数类型的 bean，则会引发致命错误。
|===

使用 `byType` 或 `constructor` 自动装配模式时，你可以装配数组和类型化集合。在这种情况下，容器中所有匹配预期类型的自动装配候选者都将被提供以满足依赖关系。如果预期的键类型是 `String`，你可以自动装配强类型的 `Map` 实例。自动装配的 `Map` 实例的值包含与预期类型匹配的所有 bean 实例，`Map` 实例的键包含相应的 bean 名称。

[[beans-autowired-exceptions]]
==== 自动装配的限制和缺点

当在整个项目中一致使用时，自动装配效果最佳。如果通常不使用自动装配，仅用于装配一两个 bean 定义，可能会让开发人员感到困惑。

请考虑自动装配的限制和缺点：

* `property` 和 `constructor-arg` 设置中的显式依赖项始终覆盖自动装配。你不能自动装配简单属性，如基本类型、`Strings` 和 `Classes`（以及这些简单属性的数组）。这种限制是有意设计的。
* 自动装配不如显式装配精确。尽管如前表所述，Spring 在避免由于可能产生意外结果的歧义而导致的猜测方面非常谨慎。Spring 管理的对象之间的关系不再明确记录。
* 生成文档的工具可能无法获取装配信息。
* 容器中可能存在多个 bean 定义与要自动装配的 setter 方法或构造函数参数指定的类型匹配。对于数组、集合或 `Map` 实例，这不一定是问题。然而，对于期望单一值的依赖关系，这种歧义不会被随意解决。如果没有唯一的 bean 定义可用，则会抛出异常。

在后一种情况下，你有以下几种选择：

* 放弃自动装配，转而使用显式装配。
* 通过将 bean 定义的 `autowire-candidate` 属性设置为 `false` 来避免自动装配，详见 <<beans-factory-autowire-candidate,下一节>>。
* 通过将其 `<bean/>` 元素的 `primary` 属性设置为 `true`，将单个 bean 定义指定为主要候选项。
* 实现基于注解配置的更细粒度控制，详见 <<beans-annotation-config>>。




[[beans-factory-autowire-candidate]]
==== 排除 Bean 的自动装配

你可以在每个 bean 的基础上排除 bean 的自动装配。在 Spring 的 XML 格式中，将 `<bean/>` 元素的 `autowire-candidate` 属性设置为 `false`。容器使该特定的 bean 定义对于自动装配基础设施不可用（包括诸如 <<beans-autowired-annotation,`@Autowired`>> 的注解风格配置）。

注意：`autowire-candidate` 属性设计为仅影响基于类型的自动装配。它不影响按名称的显式引用，即使指定的 bean 未标记为自动装配候选项，这些引用也会被解析。因此，如果名称匹配，按名称自动装配仍然会注入一个 bean。

你还可以根据与 bean 名称的模式匹配来限制自动装配候选项。顶级 `<beans/>` 元素在其 `default-autowire-candidates` 属性中接受一个或多个模式。例如，要将自动装配候选项状态限制为名称以 `Repository` 结尾的任何 bean，请提供值 `*Repository`。要提供多个模式，请在逗号分隔的列表中定义它们。对于 bean 定义的 `autowire-candidate` 属性的显式 `true` 或 `false` 值始终优先。在这种情况下，模式匹配规则不适用。

这些技术对于那些你不希望通过自动装配注入到其他 bean 的 bean 非常有用。这并不意味着排除的 bean 本身不能使用自动装配进行配置。相反，该 bean 本身不是自动装配其他 bean 的候选项。

[[beans-factory-method-injection]]
=== 方法注入

在大多数应用场景中，容器中的大多数 bean 是 <<beans-factory-scopes-singleton,单例>>。当单例 bean 需要与另一个单例 bean 协作，或非单例 bean 需要与另一个非单例 bean 协作时，通常通过将一个 bean 定义为另一个 bean 的属性来处理依赖关系。当 bean 的生命周期不同步时，会出现问题。假设单例 bean A 需要在每次调用 A 上的方法时使用非单例（原型）bean B。容器仅创建一次单例 bean A，因此只有一次机会设置属性。容器不能每次需要时都为 bean A 提供一个新的 bean B 实例。

一个解决方案是放弃一些控制反转。你可以通过实现 `ApplicationContextAware` 接口 <<beans-factory-aware,使 bean A 感知容器>>，并通过 <<beans-factory-client,向容器请求一个（通常是新的）bean B 实例>>，每次 bean A 需要时都获取它。以下示例展示了这种方法：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// 一个使用状态命令样式类执行某些处理的类
	package fiona.apple;

	// Spring-API 导入
	import org.springframework.beans.BeansException;
	import org.springframework.context.ApplicationContext;
	import org.springframework.context.ApplicationContextAware;

	public class CommandManager implements ApplicationContextAware {

		private ApplicationContext applicationContext;

		public Object process(Map commandState) {
			// 获取适当命令的新实例
			Command command = createCommand();
			// 在（希望是全新）的命令实例上设置状态
			command.setState(commandState);
			return command.execute();
		}

		protected Command createCommand() {
			// 注意 Spring API 依赖！
			return this.applicationContext.getBean("command", Command.class);
		}

		public void setApplicationContext(
				ApplicationContext applicationContext) throws BeansException {
			this.applicationContext = applicationContext;
		}
	}
----

上述方法并不理想，因为业务代码意识到并且与 Spring 框架耦合。方法注入是 Spring IoC 容器的一个较高级特性，它允许你干净地处理这种用例。

****
你可以在 https://spring.io/blog/2004/08/06/method-injection/[此博客文章] 中了解有关方法注入动机的更多信息。
****




[[beans-factory-lookup-method-injection]]
==== 查找方法注入

查找方法注入是容器能够覆盖容器管理的 bean 上的方法并返回容器中另一个命名 bean 的查找结果的能力。查找通常涉及原型 bean，如 <<beans-factory-method-injection,前一节>> 中描述的场景。Spring 框架通过使用 CGLIB 库的字节码生成动态生成一个子类来实现此方法注入，该子类会覆盖该方法。

[NOTE]
====
* 为了使这种动态子类化工作，Spring bean 容器子类化的类不能是 `final`，要覆盖的方法也不能是 `final`。
* 对具有 `abstract` 方法的类进行单元测试时，需要自行子类化该类，并提供 `abstract` 方法的存根实现。
* 对于组件扫描，也需要具体方法，因为需要扫描具体类。
* 另一个关键限制是查找方法不适用于工厂方法，特别是不适用于配置类中的 `@Bean` 方法，因为在这种情况下，容器不负责创建实例，因此无法在运行时动态生成子类。
====

在前面的代码片段中，对于 `CommandManager` 类，Spring 容器动态地覆盖了 `createCommand()` 方法的实现。正如重新编写的示例所示，`CommandManager` 类不再具有任何 Spring 依赖项：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	package fiona.apple;

	// 不再需要 Spring 导入！

	public abstract class CommandManager {

		public Object process(Object commandState) {
			// 获取适当 Command 接口的新实例
			Command command = createCommand();
			// 在（希望是全新）的 Command 实例上设置状态
			command.setState(commandState);
			return command.execute();
		}

		// 好的...但这个方法的实现在哪里？
		protected abstract Command createCommand();
	}
----

在包含要注入方法的客户端类（在本例中为 `CommandManager`）中，要注入的方法需要具有以下形式的签名：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<public|protected> [abstract] <return-type> theMethodName(no-arguments);
----

如果方法是 `abstract` 的，动态生成的子类将实现该方法。否则，动态生成的子类将覆盖原始类中定义的具体方法。考虑以下示例：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<!-- 作为原型（非单例）部署的有状态 bean -->
	<bean id="myCommand" class="fiona.apple.AsyncCommand" scope="prototype">
		<!-- 根据需要在此注入依赖项 -->
	</bean>

	<!-- commandProcessor 使用 statefulCommandHelper -->
	<bean id="commandManager" class="fiona.apple.CommandManager">
		<lookup-method name="createCommand" bean="myCommand"/>
	</bean>
----

每当 `commandManager` 标识的 bean 需要 `myCommand` bean 的新实例时，它都会调用自己的 `createCommand()` 方法。如果确实需要 `myCommand` 是原型 bean，则必须小心将其部署为原型。如果它是一个 <<beans-factory-scopes-singleton,单例>>，则每次返回的都是同一个 `myCommand` bean 实例。

或者，在基于注解的组件模型中，你可以通过 `@Lookup` 注解声明一个查找方法，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public abstract class CommandManager {

		public Object process(Object commandState) {
			Command command = createCommand();
			command.setState(commandState);
			return command.execute();
		}

		@Lookup("myCommand")
		protected abstract Command createCommand();
	}
----

或者，更为惯用的做法是，可以依赖于根据查找方法声明的返回类型解析目标 bean：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public abstract class CommandManager {

		public Object process(Object commandState) {
			Command command = createCommand();
			command.setState(commandState);
			return command.execute();
		}

		@Lookup
		protected abstract Command createCommand();
	}
----

请注意，通常应该为这些注解的查找方法声明一个具体的存根实现，以使它们与 Spring 的组件扫描规则兼容，默认情况下会忽略抽象类。此限制不适用于显式注册或显式导入的 bean 类。

[TIP]
====
访问不同作用域目标 bean 的另一种方式是使用 `ObjectFactory`/`Provider` 注入点。参见 <<beans-factory-scopes-other-injection>>。

你还可能会发现 `ServiceLocatorFactoryBean`（位于 `org.springframework.beans.factory.config` 包中）很有用。
====



[[beans-factory-arbitrary-method-replacement]]
==== 任意方法替换

与查找方法注入相比，方法注入的一个较不常用的形式是能够用另一个方法实现替换受管理的 bean 中的任意方法。除非你实际需要此功能，否则可以安全地跳过本节内容。

使用基于 XML 的配置元数据，你可以使用 `replaced-method` 元素为已部署的 bean 替换现有方法实现。考虑以下类，它有一个名为 `computeValue` 的方法，我们希望覆盖它：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MyValueCalculator {

		public String computeValue(String input) {
			// 一些真实代码...
		}

		// 其他一些方法...
	}
----

一个实现了 `org.springframework.beans.factory.support.MethodReplacer` 接口的类提供了新的方法定义，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	/**
	 * 用于覆盖 MyValueCalculator 中现有的 computeValue(String) 实现
	 */
	public class ReplacementComputeValue implements MethodReplacer {

		public Object reimplement(Object o, Method m, Object[] args) throws Throwable {
			// 获取输入值，对其进行处理并返回计算结果
			String input = (String) args[0];
			...
			return ...;
		}
	}
----

部署原始类并指定方法覆盖的 bean 定义类似于以下示例：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="myValueCalculator" class="x.y.z.MyValueCalculator">
		<!-- 任意方法替换 -->
		<replaced-method name="computeValue" replacer="replacementComputeValue">
			<arg-type>String</arg-type>
		</replaced-method>
	</bean>

	<bean id="replacementComputeValue" class="a.b.c.ReplacementComputeValue"/>
----

你可以在 `<replaced-method/>` 元素中使用一个或多个 `<arg-type/>` 元素来指示要覆盖的方法的签名。仅当方法被重载并且类中存在多个变体时，才需要为参数提供签名。为了方便起见，参数的类型字符串可以是完全限定类型名称的子字符串。例如，以下内容都匹配 `java.lang.String`：

[source,java,indent=0,subs="verbatim,quotes"]
----
	java.lang.String
	String
	Str
----

因为参数的数量通常足以区分每种可能的选择，所以这种快捷方式可以让你仅输入匹配参数类型的最短字符串，从而节省大量输入时间。




[[beans-factory-scopes]]
== Bean 作用域

当你创建一个 bean 定义时，你实际上是创建了一个用于生成由该 bean 定义的类的实际实例的配方。将 bean 定义视为配方的概念非常重要，因为这意味着，与类一样，你可以从一个配方中创建许多对象实例。

你不仅可以控制从特定 bean 定义创建的对象中要插入的各种依赖项和配置值，还可以控制从特定 bean 定义创建的对象的作用域。这种方法既强大又灵活，因为你可以通过配置选择你创建的对象的作用域，而不必在 Java 类级别中嵌入对象的作用域。bean 可以定义为在多种作用域中的一种进行部署。Spring 框架支持六种作用域，其中四种仅在使用支持 web 的 `ApplicationContext` 时可用。你还可以创建 <<beans-factory-scopes-custom,自定义作用域>>。

下表描述了支持的作用域：

[[beans-factory-scopes-tbl]]
.Bean 作用域
[cols="20%,80%"]
|===
| 作用域 | 说明

| <<beans-factory-scopes-singleton,singleton>>
| （默认）将单个 bean 定义限定为每个 Spring IoC 容器的单个对象实例。

| <<beans-factory-scopes-prototype,prototype>>
| 将单个 bean 定义限定为任意数量的对象实例。

| <<beans-factory-scopes-request,request>>
| 将单个 bean 定义限定为单个 HTTP 请求的生命周期。即，每个 HTTP 请求都有自己的 bean 实例，这个实例是根据单个 bean 定义创建的。仅在支持 web 的 Spring `ApplicationContext` 环境中有效。

| <<beans-factory-scopes-session,session>>
| 将单个 bean 定义限定为 HTTP `Session` 的生命周期。仅在支持 web 的 Spring `ApplicationContext` 环境中有效。

| <<beans-factory-scopes-application,application>>
| 将单个 bean 定义限定为 `ServletContext` 的生命周期。仅在支持 web 的 Spring `ApplicationContext` 环境中有效。

| <<web.adoc#websocket-stomp-websocket-scope,websocket>>
| 将单个 bean 定义限定为 `WebSocket` 的生命周期。仅在支持 web 的 Spring `ApplicationContext` 环境中有效。
|===

注意：从 Spring 3.0 开始，线程作用域是可用的，但默认情况下未注册。有关更多信息，请参阅 {api-spring-framework}/context/support/SimpleThreadScope.html[`SimpleThreadScope`] 的文档。有关如何注册此自定义作用域或其他自定义作用域的说明，请参阅 <<beans-factory-scopes-custom-using>>。

[[beans-factory-scopes-singleton]]
=== 单例作用域

只有一个共享实例的单例 bean 被管理，并且所有对具有与该 bean 定义匹配的 ID 或 ID 的 bean 的请求，Spring 容器都会返回该特定的 bean 实例。

换句话说，当你定义一个 bean 定义并将其限定为单例时，Spring IoC 容器会精确地创建由该 bean 定义定义的对象的一个实例。这个单一实例被存储在这些单例 bean 的缓存中，并且所有后续请求和对该命名 bean 的引用都返回缓存的对象。下图展示了单例作用域的工作原理：

image::images/singleton.png[]

Spring 的单例 bean 概念与 Gang of Four (GoF) 模式书中定义的单例模式有所不同。GoF 单例硬编码了对象的作用域，以便每个 ClassLoader 只创建特定类的一个实例。Spring 单例的作用域最好描述为每个容器和每个 bean。这意味着，如果你在一个 Spring 容器中为特定类定义了一个 bean，则 Spring 容器只会创建该 bean 定义所定义的类的一个实例。单例作用域是 Spring 中的默认作用域。要在 XML 中将 bean 定义为单例，可以定义一个 bean，如下例所示：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="accountService" class="com.something.DefaultAccountService"/>

	<!-- 以下是等效的，尽管冗余（单例作用域是默认值） -->
	<bean id="accountService" class="com.something.DefaultAccountService" scope="singleton"/>
----

[[beans-factory-scopes-prototype]]
=== 原型作用域

非单例的原型作用域导致每次请求该特定 bean 时都会创建一个新的 bean 实例。也就是说，bean 被注入到另一个 bean 中，或者你通过容器上的 `getBean()` 方法调用请求它。通常，你应该为所有有状态的 bean 使用原型作用域，为无状态的 bean 使用单例作用域。

下图展示了 Spring 原型作用域：

image::images/prototype.png[]

（数据访问对象 (DAO) 通常不会配置为原型，因为典型的 DAO 不持有任何会话状态。我们重复使用了单例图的核心部分。）

以下示例在 XML 中将 bean 定义为原型：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="accountService" class="com.something.DefaultAccountService" scope="prototype"/>
----

与其他作用域相比，Spring 不会完全管理原型 bean 的生命周期。容器实例化、配置并以其他方式组装原型对象，然后将其交给客户端，不再记录该原型实例。因此，尽管在所有对象上都会调用初始化生命周期回调方法，但在原型的情况下，不会调用配置的销毁生命周期回调。客户端代码必须清理原型作用域的对象并释放原型 bean 持有的昂贵资源。要让 Spring 容器释放原型作用域 bean 持有的资源，可以尝试使用自定义 <<beans-factory-extension-bpp,bean 后处理器>>，它持有需要清理的 bean 的引用。

在某些方面，Spring 容器在处理原型作用域的 bean 时，其角色相当于 Java `new` 运算符。在此之后的所有生命周期管理都必须由客户端处理。（有关 Spring 容器中 bean 的生命周期的详细信息，请参阅 <<beans-factory-lifecycle>>。）




[[beans-factory-scopes-sing-prot-interaction]]
=== 具有原型依赖的单例 Bean

当你使用具有原型 bean 依赖关系的单例作用域 bean 时，请注意依赖关系是在实例化时解析的。因此，如果你将一个原型作用域的 bean 依赖注入到一个单例作用域的 bean 中，将实例化一个新的原型 bean 并将其注入到单例 bean 中。该原型实例是唯一一个提供给单例作用域 bean 的实例。

但是，假设你希望单例作用域的 bean 在运行时反复获取原型作用域 bean 的新实例。你不能将原型作用域的 bean 依赖注入到单例 bean 中，因为这种注入只发生一次，即 Spring 容器实例化单例 bean 时，解析并注入其依赖项。如果你需要在运行时多次获取原型 bean 的新实例，请参阅 <<beans-factory-method-injection>>。

[[beans-factory-scopes-other]]
=== 请求、会话、应用程序和 WebSocket 作用域

`request`、`session`、`application` 和 `websocket` 作用域仅在使用支持 web 的 Spring `ApplicationContext` 实现（例如 `XmlWebApplicationContext`）时可用。如果在常规 Spring IoC 容器（如 `ClassPathXmlApplicationContext`）中使用这些作用域，将会抛出 `IllegalStateException`，提示未知的 bean 作用域。

[[beans-factory-scopes-other-web-configuration]]
==== 初始 Web 配置

要支持在 `request`、`session`、`application` 和 `websocket` 级别的 bean 作用域（web 作用域的 bean），在定义 bean 之前需要进行一些初始配置。（这种初始设置对标准作用域 `singleton` 和 `prototype` 是不需要的。）

如何完成这种初始设置取决于你的具体 Servlet 环境。

如果你在 Spring Web MVC 中访问作用域的 bean，实际上是在由 Spring 的 `DispatcherServlet` 处理的请求中访问，则不需要进行特殊设置。`DispatcherServlet` 已经暴露了所有相关的状态。

如果你使用的是 Servlet 2.5 的 web 容器，并且请求是在 Spring 的 `DispatcherServlet` 之外处理的（例如，当使用 JSF 或 Struts 时），则需要注册 `org.springframework.web.context.request.RequestContextListener` 作为 `ServletRequestListener`。对于 Servlet 3.0+，可以通过使用 `WebApplicationInitializer` 接口以编程方式完成此操作。或者，对于较旧的容器，可以将以下声明添加到 web 应用程序的 `web.xml` 文件中：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<web-app>
		...
		<listener>
			<listener-class>
				org.springframework.web.context.request.RequestContextListener
			</listener-class>
		</listener>
		...
	</web-app>
----

或者，如果你的监听器设置存在问题，可以考虑使用 Spring 的 `RequestContextFilter`。过滤器映射取决于周围的 web 应用程序配置，因此你必须根据需要进行更改。以下代码展示了 web 应用程序中的过滤器部分：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<web-app>
		...
		<filter>
			<filter-name>requestContextFilter</filter-name>
			<filter-class>org.springframework.web.filter.RequestContextFilter</filter-class>
		</filter>
		<filter-mapping>
			<filter-name>requestContextFilter</filter-name>
			<url-pattern>/*</url-pattern>
		</filter-mapping>
		...
	</web-app>
----

`DispatcherServlet`、`RequestContextListener` 和 `RequestContextFilter` 都执行相同的操作，即将 HTTP 请求对象绑定到正在处理该请求的 `Thread`。这使得请求作用域和会话作用域的 bean 可以在调用链的后续部分中使用。




[[beans-factory-scopes-request]]
==== 请求作用域

考虑以下 bean 定义的 XML 配置：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="loginAction" class="com.something.LoginAction" scope="request"/>
----

Spring 容器使用 `loginAction` bean 定义为每一个 HTTP 请求创建一个新的 `LoginAction` bean 实例。也就是说，`loginAction` bean 在 HTTP 请求级别上具有作用域。你可以随意更改创建的实例的内部状态，因为从相同 `loginAction` bean 定义创建的其他实例不会看到这些状态变化。它们特定于单个请求。当请求处理完成时，作用域限定在该请求的 bean 将被丢弃。

在使用注解驱动的组件或 Java 配置时，可以使用 `@RequestScope` 注解将组件分配给 `request` 作用域。以下示例展示了如何操作：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@RequestScope
	@Component
	public class LoginAction {
		// ...
	}
----


[[beans-factory-scopes-session]]
==== 会话作用域

考虑以下 bean 定义的 XML 配置：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="userPreferences" class="com.something.UserPreferences" scope="session"/>
----

Spring 容器使用 `userPreferences` bean 定义为单个 HTTP `Session` 的生命周期创建一个新的 `UserPreferences` bean 实例。换句话说，`userPreferences` bean 实际上在 HTTP `Session` 级别上具有作用域。与请求作用域的 bean 一样，你可以随意更改创建的实例的内部状态，知道其他 HTTP `Session` 实例也使用从相同 `userPreferences` bean 定义创建的实例时不会看到这些状态变化，因为它们特定于单个 HTTP `Session`。当 HTTP `Session` 最终被丢弃时，限定在该特定 HTTP `Session` 的 bean 也会被丢弃。

在使用注解驱动的组件或 Java 配置时，你可以使用 `@SessionScope` 注解将组件分配给 `session` 作用域。

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@SessionScope
	@Component
	public class UserPreferences {
		// ...
	}
----


[[beans-factory-scopes-application]]
==== 应用程序作用域

考虑以下 bean 定义的 XML 配置：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="appPreferences" class="com.something.AppPreferences" scope="application"/>
----

Spring 容器使用 `appPreferences` bean 定义为整个 web 应用程序创建一次 `AppPreferences` bean 实例。也就是说，`appPreferences` bean 在 `ServletContext` 级别上具有作用域，并作为常规 `ServletContext` 属性存储。这有点类似于 Spring 的单例 bean，但在两个重要方面有所不同：它是每个 `ServletContext` 的单例，而不是每个 Spring `ApplicationContext`（在任何给定的 web 应用程序中可能有多个），并且它实际上是作为 `ServletContext` 属性公开的，因此是可见的。

在使用注解驱动的组件或 Java 配置时，可以使用 `@ApplicationScope` 注解将组件分配给 `application` 作用域。以下示例展示了如何操作：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ApplicationScope
	@Component
	public class AppPreferences {
		// ...
	}
----


[[beans-factory-scopes-websocket]]
==== WebSocket 作用域

WebSocket 作用域与 WebSocket 会话的生命周期相关联，适用于基于 WebSocket 的 STOMP 应用程序，详细信息请参见 <<web.adoc#websocket-stomp-websocket-scope,WebSocket 作用域>>。


[[beans-factory-scopes-other-injection]]
==== 作为依赖项的作用域 Bean

Spring IoC 容器不仅管理对象（bean）的实例化，还负责协作对象（或依赖项）的连接。如果你想将一个 HTTP 请求作用域的 bean 注入到另一个生命周期较长的 bean 中，你可以选择在作用域 bean 位置注入一个 AOP 代理。也就是说，你需要注入一个代理对象，该代理对象公开与作用域对象相同的公共接口，但还可以从相关作用域（如 HTTP 请求）中检索实际目标对象并将方法调用委托给真实对象。

[NOTE]
====
你还可以在作用域为 `singleton` 的 bean 之间使用 `<aop:scoped-proxy/>`，此时引用将通过一个中间代理进行，该代理是可序列化的，因此能够在反序列化时重新获取目标单例 bean。

当为 `prototype` 作用域的 bean 声明 `<aop:scoped-proxy/>` 时，对共享代理的每次方法调用都会导致创建一个新的目标实例，然后将调用转发给该实例。

此外，作用域代理并不是在生命周期安全的方式中访问较短作用域的 bean 的唯一方法。你还可以将注入点（即构造函数或 setter 参数或自动注入字段）声明为 `ObjectFactory<MyTargetBean>`，从而允许 `getObject()` 调用每次需要时按需检索当前实例——而不持有实例或单独存储它。

作为扩展变体，你可以声明 `ObjectProvider<MyTargetBean>`，它提供了多个额外的访问变体，包括 `getIfAvailable` 和 `getIfUnique`。

JSR-330 的变体称为 `Provider`，使用 `Provider<MyTargetBean>` 声明并在每次检索时调用相应的 `get()` 方法。有关 JSR-330 的更多详细信息，请参见 <<beans-standard-annotations,此处>>。
====

以下示例中的配置只有一行，但理解其背后的“为什么”以及“如何”是非常重要的：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:aop="http://www.springframework.org/schema/aop"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/aop
			https://www.springframework.org/schema/aop/spring-aop.xsd">

		<!-- 作为代理公开的 HTTP Session 作用域的 bean -->
		<bean id="userPreferences" class="com.something.UserPreferences" scope="session">
			<!-- 指示容器代理周围的 bean -->
			<aop:scoped-proxy/> <1>
		</bean>

		<!-- 一个单例作用域的 bean，注入了对上述 bean 的代理 -->
		<bean id="userService" class="com.something.SimpleUserService">
			<!-- 对代理的 userPreferences bean 的引用 -->
			<property name="userPreferences" ref="userPreferences"/>
		</bean>
	</beans>
----
<1> 定义代理的行。

要创建这样的代理，你需要在作用域 bean 定义中插入一个子 `<aop:scoped-proxy/>` 元素（参见 <<beans-factory-scopes-other-injection-proxies>> 和 <<core.adoc#xsd-schemas, 基于 XML 架构的配置>>）。为什么 `request`、`session` 和自定义作用域级别的 bean 定义需要 `<aop:scoped-proxy/>` 元素？考虑以下单例 bean 定义，并将其与上述作用域所需的定义进行对比（请注意，以下 `userPreferences` bean 定义在其当前状态下是不完整的）：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="userPreferences" class="com.something.UserPreferences" scope="session"/>

	<bean id="userManager" class="com.something.UserManager">
		<property name="userPreferences" ref="userPreferences"/>
	</bean>
----

在上述示例中，单例 bean (`userManager`) 注入了对 HTTP `Session` 作用域 bean (`userPreferences`) 的引用。这里的要点是 `userManager` bean 是一个单例：它每个容器实例化一次，并且它的依赖项（在本例中只有一个，即 `userPreferences` bean）也只注入一次。这意味着 `userManager` bean 仅对其最初注入的 `userPreferences` 对象进行操作。

当将生命周期较短的作用域 bean 注入到生命周期较长的作用域 bean 时（例如，将 HTTP `Session` 作用域的协作 bean 注入到单例 bean 中），这并不是你想要的行为。相反，你需要一个单一的 `userManager` 对象，并且在 HTTP `Session` 的生命周期内，你需要一个特定于 HTTP `Session` 的 `userPreferences` 对象。因此，容器创建一个公开与 `UserPreferences` 类完全相同公共接口的对象（理想情况下是一个 `UserPreferences` 实例），该对象可以从作用域机制（HTTP 请求、`Session` 等）中获取实际的 `UserPreferences` 对象。容器将此代理对象注入到 `userManager` bean 中，而 `userManager` bean 不知道此 `UserPreferences` 引用是代理。在本示例中，当 `UserManager` 实例调用依赖注入的 `UserPreferences` 对象上的方法时，实际上是在调用代理上的方法。然后代理从 HTTP `Session` 中获取实际的 `UserPreferences` 对象，并将方法调用委托给获取的实际 `UserPreferences` 对象。

因此，在将 `request` 和 `session` 作用域的 bean 注入到协作对象中时，你需要如下所示的（正确且完整的）配置：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="userPreferences" class="com.something.UserPreferences" scope="session">
		<aop:scoped-proxy/>
	</bean>

	<bean id="userManager" class="com.something.UserManager">
		<property name="userPreferences" ref="userPreferences"/>
	</bean>
----

[[beans-factory-scopes-other-injection-proxies]]
===== 选择要创建的代理类型

默认情况下，当 Spring 容器为带有 `<aop:scoped-proxy/>` 元素的 bean 创建代理时，会创建基于 CGLIB 的类代理。

[NOTE]
====
CGLIB 代理仅拦截公共方法调用！请不要在这样的代理上调用非公共方法。它们不会被委托到实际的作用域目标对象。
====

或者，你可以配置 Spring 容器为这些作用域 bean 创建基于标准 JDK 接口的代理，只需将 `<aop:scoped-proxy/>` 元素的 `proxy-target-class` 属性的值指定为 `false`。使用 JDK 接口代理意味着你不需要在应用程序类路径中添加额外的库来实现这种代理。但是，这也意味着作用域 bean 的类必须至少实现一个接口，并且所有将作用域 bean 注入到其中的协作对象必须通过其接口引用该 bean。以下示例展示了基于接口的代理：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<!-- DefaultUserPreferences 实现了 UserPreferences 接口 -->
	<bean id="userPreferences" class="com.stuff.DefaultUserPreferences" scope="session">
		<aop:scoped-proxy proxy-target-class="false"/>
	</bean>

	<bean id="userManager" class="com.stuff.UserManager">
		<property name="userPreferences" ref="userPreferences"/>
	</bean>
----

有关选择基于类的代理或基于接口的代理的详细信息，请参阅 <<aop-proxying>>。




[[beans-factory-scopes-custom]]
=== 自定义作用域

Bean 的作用域机制是可扩展的。你可以定义自己的作用域，甚至可以重新定义现有的作用域，尽管后者被认为是不好的做法，而且你不能覆盖内置的 `singleton` 和 `prototype` 作用域。


[[beans-factory-scopes-custom-creating]]
==== 创建自定义作用域

要将自定义作用域集成到 Spring 容器中，你需要实现 `org.springframework.beans.factory.config.Scope` 接口，该接口在本节中进行了描述。要了解如何实现自己的作用域，可以参考 Spring 框架本身提供的 `Scope` 实现以及 {api-spring-framework}/beans/factory/config/Scope.html[`Scope`] javadoc，它更详细地解释了需要实现的方法。

`Scope` 接口有四个方法用于从作用域中获取对象、将它们从作用域中移除，并让它们被销毁。

例如，session 作用域的实现返回 session 作用域的 bean（如果不存在，该方法返回一个新的 bean 实例，并在将其绑定到 session 以供将来引用后返回）。以下方法从底层作用域中返回对象：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	Object get(String name, ObjectFactory<?> objectFactory)
----

例如，session 作用域的实现从底层 session 中移除 session 作用域的 bean。对象应该被返回，但如果找不到指定名称的对象，你可以返回 `null`。以下方法从底层作用域中移除对象：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	Object remove(String name)
----

以下方法注册一个回调，该回调将在作用域被销毁或作用域中的指定对象被销毁时被调用：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	void registerDestructionCallback(String name, Runnable destructionCallback)
----

有关销毁回调的更多信息，请参阅 {api-spring-framework}/beans/factory/config/Scope.html#registerDestructionCallback[javadoc] 或 Spring 的某个作用域实现。

以下方法获取底层作用域的会话标识符：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	String getConversationId()
----

每个作用域的标识符是不同的。对于 session 作用域的实现，该标识符可以是 session 标识符。



[[beans-factory-scopes-custom-using]]
==== 使用自定义作用域

在编写并测试一个或多个自定义 `Scope` 实现后，你需要让 Spring 容器知道你的新作用域。以下方法是向 Spring 容器注册新 `Scope` 的核心方法：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	void registerScope(String scopeName, Scope scope);
----

此方法在 `ConfigurableBeanFactory` 接口中声明，该接口可以通过大多数 Spring 附带的具体 `ApplicationContext` 实现上的 `BeanFactory` 属性获得。

`registerScope(..)` 方法的第一个参数是与作用域关联的唯一名称。Spring 容器本身中的示例名称有 `singleton` 和 `prototype`。`registerScope(..)` 方法的第二个参数是你想注册并使用的自定义 `Scope` 实现的实际实例。

假设你编写了自定义的 `Scope` 实现，然后按以下示例注册它。

注意：下一个示例使用了 `SimpleThreadScope`，它包含在 Spring 中，但默认情况下未注册。对于你自己的自定义 `Scope` 实现，操作方法相同。

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	Scope threadScope = new SimpleThreadScope();
	beanFactory.registerScope("thread", threadScope);
----

然后，你可以创建符合自定义 `Scope` 作用域规则的 bean 定义，如下所示：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="..." class="..." scope="thread">
----

使用自定义 `Scope` 实现时，你不限于以编程方式注册作用域。你还可以使用 `CustomScopeConfigurer` 类以声明方式进行 `Scope` 注册，如下例所示：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:aop="http://www.springframework.org/schema/aop"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/aop
			https://www.springframework.org/schema/aop/spring-aop.xsd">

		<bean class="org.springframework.beans.factory.config.CustomScopeConfigurer">
			<property name="scopes">
				<map>
					<entry key="thread">
						<bean class="org.springframework.context.support.SimpleThreadScope"/>
					</entry>
				</map>
			</property>
		</bean>

		<bean id="thing2" class="x.y.Thing2" scope="thread">
			<property name="name" value="Rick"/>
			<aop:scoped-proxy/>
		</bean>

		<bean id="thing1" class="x.y.Thing1">
			<property name="thing2" ref="thing2"/>
		</bean>

	</beans>
----

注意：当你将 `<aop:scoped-proxy/>` 放置在 `FactoryBean` 实现的 `<bean>` 声明中时，作用域的是工厂 bean 本身，而不是从 `getObject()` 返回的对象。



[[beans-factory-lifecycle-disposablebean]]
==== 销毁回调

实现 `org.springframework.beans.factory.DisposableBean` 接口可以让 bean 在包含它的容器被销毁时获得回调。`DisposableBean` 接口指定了一个单一方法：

[source,java,indent=0,subs="verbatim,quotes"]
----
	void destroy() throws Exception;
----

我们建议你不要使用 `DisposableBean` 回调接口，因为它会不必要地将代码与 Spring 耦合在一起。相反，我们建议使用 <<beans-postconstruct-and-predestroy-annotations, `@PreDestroy`>> 注解或指定 bean 定义所支持的通用方法。在基于 XML 的配置元数据中，你可以在 `<bean/>` 上使用 `destroy-method` 属性。在 Java 配置中，你可以使用 `@Bean` 的 `destroyMethod` 属性。参见 <<beans-java-lifecycle-callbacks>>。考虑以下定义：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="exampleInitBean" class="examples.ExampleBean" destroy-method="cleanup"/>
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class ExampleBean {

		public void cleanup() {
			// 执行一些销毁工作（例如释放连接池中的连接）
		}
	}
----

上述定义与以下定义几乎完全相同：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="exampleInitBean" class="examples.AnotherExampleBean"/>
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class AnotherExampleBean implements DisposableBean {

		@Override
		public void destroy() {
			// 执行一些销毁工作（例如释放连接池中的连接）
		}
	}
----

然而，第一个定义并没有将代码与 Spring 耦合。

提示：你可以将 `<bean>` 元素的 `destroy-method` 属性指定为特殊的 `(inferred)` 值，这会指示 Spring 自动检测特定 bean 类上的公共 `close` 或 `shutdown` 方法。（因此，任何实现了 `java.lang.AutoCloseable` 或 `java.io.Closeable` 的类都可以匹配。）你还可以在 `<beans>` 元素的 `default-destroy-method` 属性上设置这个特殊的 `(inferred)` 值，以将此行为应用于整个 bean 集合（参见 <<beans-factory-lifecycle-default-init-destroy-methods>>）。请注意，这是 Java 配置的默认行为。

[[beans-factory-lifecycle-default-init-destroy-methods]]
==== 默认初始化和销毁方法

当你编写不使用 Spring 特定的 `InitializingBean` 和 `DisposableBean` 回调接口的初始化和销毁方法回调时，通常会编写名称如 `init()`、`initialize()`、`dispose()` 等方法。理想情况下，这些生命周期回调方法的名称应在整个项目中标准化，以便所有开发人员都使用相同的方法名称，并确保一致性。

你可以配置 Spring 容器以便“查找”每个 bean 上的命名初始化和销毁回调方法名称。这意味着你作为应用程序开发人员可以编写使用名为 `init()` 的初始化回调的方法的应用程序类，而不必在每个 bean 定义中配置 `init-method="init"` 属性。Spring IoC 容器在创建 bean 时会调用该方法（并根据 <<beans-factory-lifecycle,前面描述的标准生命周期回调契约>> 在适当的时候调用该方法）。此功能还强制执行初始化和销毁方法回调的命名约定。

假设你的初始化回调方法名为 `init()`，你的销毁回调方法名为 `destroy()`。你的类可能类似于以下示例中的类：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class DefaultBlogService implements BlogService {

		private BlogDao blogDao;

		public void setBlogDao(BlogDao blogDao) {
			this.blogDao = blogDao;
		}

		// 这就是（毫不意外地）初始化回调方法
		public void init() {
			if (this.blogDao == null) {
				throw new IllegalStateException("必须设置 [blogDao] 属性。");
			}
		}
	}
----

然后你可以在一个 bean 中使用该类，类似于以下示例：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans default-init-method="init">

		<bean id="blogService" class="com.something.DefaultBlogService">
			<property name="blogDao" ref="blogDao" />
		</bean>

	</beans>
----

顶级 `<beans/>` 元素上的 `default-init-method` 属性的存在使得 Spring IoC 容器能够将 bean 类上的名为 `init` 的方法识别为初始化方法回调。当创建并组装一个 bean 时，如果 bean 类具有此类方法，它将在适当的时候被调用。

你可以通过在顶级 `<beans/>` 元素上使用 `default-destroy-method` 属性类似地配置销毁方法回调（基于 XML 的配置）。

对于已经有与约定名称不同的回调方法的现有 bean 类，你可以通过使用 `<bean/>` 本身的 `init-method` 和 `destroy-method` 属性来覆盖默认值。

Spring 容器保证在 bean 提供所有依赖项后立即调用已配置的初始化回调。因此，初始化回调是在原始 bean 引用上调用的，这意味着 AOP 拦截器等尚未应用于 bean。目标 bean 首先被完全创建，然后应用 AOP 代理（例如）及其拦截器链。如果目标 bean 和代理是单独定义的，你的代码甚至可以直接与原始目标 bean 交互，绕过代理。因此，将拦截器应用于 `init` 方法是不一致的，因为这样做会将目标 bean 的生命周期与其代理或拦截器耦合，并在你的代码直接与原始目标 bean 交互时留下奇怪的语义。



[[beans-factory-lifecycle-combined-effects]]
==== 组合生命周期机制

从 Spring 2.5 开始，你有三种控制 bean 生命周期行为的选项：

* <<beans-factory-lifecycle-initializingbean, `InitializingBean`>> 和 <<beans-factory-lifecycle-disposablebean, `DisposableBean`>> 回调接口
* 自定义的 `init()` 和 `destroy()` 方法
* <<beans-postconstruct-and-predestroy-annotations, `@PostConstruct` 和 `@PreDestroy` 注解>>。你可以结合这些机制来控制一个给定的 bean。

注意：如果为一个 bean 配置了多种生命周期机制，并且每种机制配置了不同的方法名称，那么每个配置的方法将按照此说明后的顺序依次运行。然而，如果为多个生命周期机制配置了相同的方法名称（例如，为初始化方法配置了 `init()`），则该方法只运行一次，如 <<beans-factory-lifecycle-default-init-destroy-methods, 前一部分>> 中所述。

为同一个 bean 配置了多种生命周期机制，并且有不同的初始化方法时，调用顺序如下：

. 用 `@PostConstruct` 注解的方法
. `InitializingBean` 回调接口中定义的 `afterPropertiesSet()` 方法
. 自定义配置的 `init()` 方法

销毁方法按照相同的顺序调用：

. 用 `@PreDestroy` 注解的方法
. `DisposableBean` 回调接口中定义的 `destroy()` 方法
. 自定义配置的 `destroy()` 方法



[[beans-factory-lifecycle-processor]]
==== 启动和关闭回调

`Lifecycle` 接口定义了任何具有自己生命周期要求（例如启动和停止某些后台进程）的对象的基本方法：

[source,java,indent=0,subs="verbatim,quotes"]
----
	public interface Lifecycle {

		void start();

		void stop();

		boolean isRunning();
	}
----

任何 Spring 管理的对象都可以实现 `Lifecycle` 接口。然后，当 `ApplicationContext` 本身接收到启动和停止信号（例如，在运行时的停止/重启场景中），它会将这些调用级联到在该上下文中定义的所有 `Lifecycle` 实现。它通过委托给一个 `LifecycleProcessor` 来实现这一点，下面的列表展示了这个接口的定义：

[source,java,indent=0,subs="verbatim,quotes"]
----
	public interface LifecycleProcessor extends Lifecycle {

		void onRefresh();

		void onClose();
	}
----

请注意，`LifecycleProcessor` 本身也是 `Lifecycle` 接口的扩展。它还添加了两个其他方法，以便在上下文刷新和关闭时做出反应。

[TIP]
====
请注意，常规的 `org.springframework.context.Lifecycle` 接口只是一个用于显式启动和停止通知的简单合同，并不意味着在上下文刷新时自动启动。为了对特定 bean 的自动启动（包括启动阶段）进行细粒度控制，考虑实现 `org.springframework.context.SmartLifecycle` 接口。

另外，请注意，停止通知并不保证在销毁之前到来。在常规关闭时，所有 `Lifecycle` bean 首先接收到停止通知，然后再传播通用的销毁回调。然而，在上下文生命周期中的热刷新或停止的刷新尝试期间，只会调用销毁方法。
====

启动和关闭调用的顺序可能很重要。如果两个对象之间存在“`depends-on`”关系，则依赖方在其依赖项之后启动，并在其依赖项之前停止。然而，有时直接依赖关系是未知的。你可能只知道某种类型的对象应该在另一种类型的对象之前启动。在这些情况下，`SmartLifecycle` 接口定义了另一个选项，即其父接口 `Phased` 中定义的 `getPhase()` 方法。以下列表展示了 `Phased` 接口的定义：

[source,java,indent=0,subs="verbatim,quotes"]
----
	public interface Phased {

		int getPhase();
	}
----

以下是 `SmartLifecycle` 接口的定义：

[source,java,indent=0,subs="verbatim,quotes"]
----
	public interface SmartLifecycle extends Lifecycle, Phased {

		boolean isAutoStartup();

		void stop(Runnable callback);
	}
----

在启动时，具有最低阶段的对象首先启动。在停止时，顺序相反。因此，实现 `SmartLifecycle` 接口并且其 `getPhase()` 方法返回 `Integer.MIN_VALUE` 的对象将是最早启动并最后停止的对象。在另一端，`Integer.MAX_VALUE` 的阶段值表明该对象应该最后启动并最先停止（可能是因为它依赖于其他进程的运行）。在考虑阶段值时，还需要知道，任何不实现 `SmartLifecycle` 的“常规” `Lifecycle` 对象的默认阶段为 `0`。因此，任何负阶段值都表示对象应该在那些标准组件之前启动（并在它们之后停止）。对于任何正阶段值，则相反。

`SmartLifecycle` 定义的 `stop` 方法接受一个回调。任何实现都必须在该实现的关闭过程完成后调用该回调的 `run()` 方法。这样就可以在必要时实现异步关闭，因为 `LifecycleProcessor` 接口的默认实现 `DefaultLifecycleProcessor` 在每个阶段组内的对象调用该回调之前，会等待其超时时间。每个阶段的默认超时时间为 30 秒。你可以通过在上下文中定义一个名为 `lifecycleProcessor` 的 bean 来覆盖默认的生命周期处理器实例。如果只想修改超时时间，定义以下内容就足够了：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="lifecycleProcessor" class="org.springframework.context.support.DefaultLifecycleProcessor">
		<!-- 以毫秒为单位的超时时间 -->
		<property name="timeoutPerShutdownPhase" value="10000"/>
	</bean>
----

如前所述，`LifecycleProcessor` 接口还定义了上下文刷新和关闭的回调方法。后者在上下文关闭时驱动关闭过程，就像显式调用了 `stop()` 一样，但它发生在上下文关闭时。而 `refresh` 回调则启用了 `SmartLifecycle` bean 的另一个功能。当上下文刷新（在所有对象都已实例化和初始化之后）时，会调用该回调。这时，默认的生命周期处理器会检查每个 `SmartLifecycle` 对象的 `isAutoStartup()` 方法返回的布尔值。如果为 `true`，该对象会在此时启动，而不是等待显式调用上下文或它自己的 `start()` 方法（与上下文刷新不同，标准上下文实现不会自动启动上下文）。启动顺序由 `phase` 值和任何“`depends-on`”关系决定，如前面所述。



[[beans-factory-shutdown]]
==== 在非 Web 应用程序中优雅地关闭 Spring IoC 容器

[NOTE]
====
此部分仅适用于非 Web 应用程序。Spring 的基于 Web 的 `ApplicationContext` 实现已经在相关 Web 应用程序关闭时优雅地关闭 Spring IoC 容器的代码。
====

如果你在非 Web 应用程序环境中使用 Spring 的 IoC 容器（例如，在富客户端桌面环境中），请在 JVM 中注册一个关闭钩子。这样可以确保优雅地关闭，并在你的单例 bean 上调用相关的销毁方法，以便释放所有资源。你仍然需要正确配置和实现这些销毁回调。

要注册关闭钩子，可以调用 `ConfigurableApplicationContext` 接口中声明的 `registerShutdownHook()` 方法，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import org.springframework.context.ConfigurableApplicationContext;
	import org.springframework.context.support.ClassPathXmlApplicationContext;

	public final class Boot {

		public static void main(final String[] args) throws Exception {
			ConfigurableApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml");

			// 为上述上下文添加一个关闭钩子...
			ctx.registerShutdownHook();

			// 应用程序在此处运行...

			// main 方法退出，钩子在应用程序关闭前被调用...
		}
	}
----


[[beans-factory-aware]]
=== `ApplicationContextAware` 和 `BeanNameAware`

当 `ApplicationContext` 创建一个实现了 `org.springframework.context.ApplicationContextAware` 接口的对象实例时，该实例会被提供一个指向该 `ApplicationContext` 的引用。以下列表展示了 `ApplicationContextAware` 接口的定义：

[source,java,indent=0,subs="verbatim,quotes"]
----
	public interface ApplicationContextAware {

		void setApplicationContext(ApplicationContext applicationContext) throws BeansException;
	}
----

因此，bean 可以通过 `ApplicationContext` 接口或通过将引用强制转换为已知的该接口的子类（例如 `ConfigurableApplicationContext`，它公开了额外的功能）来以编程方式操作创建它的 `ApplicationContext`。一种用途是以编程方式检索其他 bean。有时这种能力很有用。然而，总的来说，你应该避免使用它，因为它会将代码与 Spring 耦合，并且不符合控制反转的风格，即通过属性向 bean 提供协作对象。`ApplicationContext` 的其他方法提供了对文件资源的访问、发布应用程序事件以及访问 `MessageSource` 的能力。这些附加功能在 <<context-introduction>> 中进行了描述。

自动装配是获取 `ApplicationContext` 引用的另一种选择。`constructor` 和 `byType` 这两种 _传统_ 的自动装配模式（如 <<beans-factory-autowire>> 中所述）可以为构造函数参数或 setter 方法参数分别提供 `ApplicationContext` 类型的依赖项。为了获得更大的灵活性，包括自动装配字段和多参数方法的能力，使用基于注解的自动装配功能。如果你这样做，`ApplicationContext` 会被自动装配到字段、构造函数参数或方法参数中，只要该字段、构造函数或方法带有 `@Autowired` 注解。有关更多信息，请参见 <<beans-autowired-annotation>>。

当 `ApplicationContext` 创建一个实现了 `org.springframework.beans.factory.BeanNameAware` 接口的类时，该类会被提供一个对其关联对象定义中定义的名称的引用。以下列表展示了 `BeanNameAware` 接口的定义：

[source,java,indent=0,subs="verbatim,quotes"]
----
	public interface BeanNameAware {

		void setBeanName(String name) throws BeansException;
	}
----

回调在正常的 bean 属性填充之后、`InitializingBean.afterPropertiesSet()` 这样的初始化回调或自定义初始化方法之前被调用。




[[aware-list]]
=== 其他 `Aware` 接口

除了 `ApplicationContextAware` 和 `BeanNameAware`（在 <<beans-factory-aware, earlier>> 中讨论过），Spring 提供了广泛的 `Aware` 回调接口，这些接口允许 bean 向容器表明它们需要某种基础设施依赖项。一般来说，接口名称表明了依赖项的类型。下表总结了最重要的 `Aware` 接口：

[[beans-factory-nature-aware-list]]
.Aware 接口
|===
| 名称 | 注入的依赖项 | 详解位置

| `ApplicationContextAware`
| 声明的 `ApplicationContext`。
| <<beans-factory-aware>>

| `ApplicationEventPublisherAware`
| 包含的 `ApplicationContext` 的事件发布者。
| <<context-introduction>>

| `BeanClassLoaderAware`
| 用于加载 bean 类的类加载器。
| <<beans-factory-class>>

| `BeanFactoryAware`
| 声明的 `BeanFactory`。
| <<beans-beanfactory>>

| `BeanNameAware`
| 声明 bean 的名称。
| <<beans-factory-aware>>

| `LoadTimeWeaverAware`
| 在加载时处理类定义的编织器。
| <<aop-aj-ltw>>

| `MessageSourceAware`
| 用于解析消息的配置策略（支持参数化和国际化）。
| <<context-introduction>>

| `NotificationPublisherAware`
| Spring JMX 通知发布者。
| <<integration.adoc#jmx-notifications, Notifications>>

| `ResourceLoaderAware`
| 用于低级别访问资源的配置加载器。
| <<resources>>

| `ServletConfigAware`
| 当前容器运行所在的 `ServletConfig`。仅在 web-aware 的 Spring `ApplicationContext` 中有效。
| <<web.adoc#mvc, Spring MVC>>

| `ServletContextAware`
| 当前容器运行所在的 `ServletContext`。仅在 web-aware 的 Spring `ApplicationContext` 中有效。
| <<web.adoc#mvc, Spring MVC>>
|===

请再次注意，使用这些接口会将代码与 Spring API 紧密耦合，并且不符合控制反转的风格。因此，我们建议它们仅用于需要程序化访问容器的基础设施 bean。

[[beans-child-bean-definitions]]
== Bean 定义继承

一个 bean 定义可以包含大量的配置信息，包括构造函数参数、属性值和容器特定信息，如初始化方法、静态工厂方法名等。子 bean 定义继承自父定义的配置信息。子定义可以根据需要覆盖一些值或添加其他值。使用父子 bean 定义可以节省大量的输入工作。实际上，这是一种模板化的形式。

如果您以编程方式使用 `ApplicationContext` 接口，子 bean 定义由 `ChildBeanDefinition` 类表示。大多数用户不会在此级别上使用它们，而是通过 `ClassPathXmlApplicationContext` 类以声明方式配置 bean 定义。当您使用基于 XML 的配置元数据时，可以通过使用 `parent` 属性来指示子 bean 定义，并将父 bean 指定为此属性的值。以下示例展示了如何进行操作：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="inheritedTestBean" abstract="true"
			class="org.springframework.beans.TestBean">
		<property name="name" value="parent"/>
		<property name="age" value="1"/>
	</bean>

	<bean id="inheritsWithDifferentClass"
			class="org.springframework.beans.DerivedTestBean"
			parent="inheritedTestBean" init-method="initialize">  <1>
		<property name="name" value="override"/>
		<!-- the age property value of 1 will be inherited from parent -->
	</bean>
----
<1> 请注意 `parent` 属性。

如果未指定类，子 bean 定义将使用父定义的 bean 类，但也可以覆盖它。在后一种情况下，子 bean 类必须与父类兼容（即它必须接受父类的属性值）。

子 bean 定义继承了父定义的范围、构造函数参数值、属性值和方法覆盖，并可以添加新值。您指定的任何范围、初始化方法、销毁方法或 `static` 工厂方法设置都会覆盖对应的父设置。

剩余的设置始终来自子定义：依赖、自动装配模式、依赖检查、单例和延迟初始化。

上面的示例通过使用 `abstract` 属性显式地将父 bean 定义标记为抽象。如果父定义未指定类，则必须显式地将父 bean 定义标记为 `abstract`，如下示例所示：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="inheritedTestBeanWithoutClass" abstract="true">
		<property name="name" value="parent"/>
		<property name="age" value="1"/>
	</bean>

	<bean id="inheritsWithClass" class="org.springframework.beans.DerivedTestBean"
			parent="inheritedTestBeanWithoutClass" init-method="initialize">
		<property name="name" value="override"/>
		<!-- age will inherit the value of 1 from the parent bean definition-->
	</bean>
----

父 bean 无法单独实例化，因为它是不完整的，并且它也被显式标记为 `abstract`。当一个定义是 `abstract` 时，它只能用作纯模板 bean 定义，用于为子定义服务。尝试单独使用这样的 `abstract` 父 bean，例如通过将其作为另一个 bean 的引用属性或通过使用父 bean ID 进行显式 `getBean()` 调用，将返回错误。同样，容器的内部 `preInstantiateSingletons()` 方法会忽略定义为抽象的 bean 定义。

注意：`ApplicationContext` 默认情况下会预先实例化所有单例。因此，如果您有一个仅用于模板的（父）bean 定义，并且此定义指定了一个类，则必须确保将 __abstract__ 属性设置为 __true__，否则应用程序上下文将实际（尝试）预先实例化 `abstract` bean。

[[beans-factory-extension]]
== 容器扩展点

通常，应用程序开发人员不需要子类化 `ApplicationContext` 实现类。相反，可以通过在 Spring IoC 容器中插入特殊集成接口的实现来扩展容器。接下来的几节将描述这些集成接口。

[[beans-factory-extension-bpp]]
=== 使用 `BeanPostProcessor` 自定义 Bean

`BeanPostProcessor` 接口定义了回调方法，您可以实现这些方法来提供自己的（或覆盖容器的默认）实例化逻辑、依赖项解析逻辑等。如果您希望在 Spring 容器完成 bean 的实例化、配置和初始化之后实现一些自定义逻辑，可以插入一个或多个自定义的 `BeanPostProcessor` 实现。

您可以配置多个 `BeanPostProcessor` 实例，并可以通过设置 `order` 属性来控制这些 `BeanPostProcessor` 实例的运行顺序。只有当 `BeanPostProcessor` 实现了 `Ordered` 接口时，才能设置此属性。如果您编写自己的 `BeanPostProcessor`，您也应该考虑实现 `Ordered` 接口。有关更多详细信息，请参阅 {api-spring-framework}/beans/factory/config/BeanPostProcessor.html[`BeanPostProcessor`] 和 {api-spring-framework}/core/Ordered.html[`Ordered`] 接口的 javadoc。另请参阅 <<beans-factory-programmatically-registering-beanpostprocessors, 程序化注册 `BeanPostProcessor` 实例>> 的注释。

[NOTE]
====
`BeanPostProcessor` 实例作用于 bean（或对象）实例。也就是说，Spring IoC 容器实例化一个 bean 实例，然后 `BeanPostProcessor` 实例开始工作。

`BeanPostProcessor` 实例是按容器范围划分的。仅当您使用容器层次结构时，这一点才有意义。如果您在一个容器中定义了一个 `BeanPostProcessor`，它只对该容器中的 bean 进行后处理。换句话说，在一个容器中定义的 bean 不会被定义在另一个容器中的 `BeanPostProcessor` 进行后处理，即使这两个容器是同一层次结构的一部分。

如果要更改实际的 bean 定义（即定义 bean 的蓝图），则需要使用 `BeanFactoryPostProcessor`，如 <<beans-factory-extension-factory-postprocessors>> 中所述。
====

`org.springframework.beans.factory.config.BeanPostProcessor` 接口由两个回调方法组成。当这样的类作为后处理器注册到容器中时，对于容器创建的每个 bean 实例，后处理器都会在容器初始化方法（如 `InitializingBean.afterPropertiesSet()` 或任何声明的 `init` 方法）调用之前和任何 bean 初始化回调之后收到来自容器的回调。后处理器可以对 bean 实例执行任何操作，包括完全忽略回调。一个 bean 后处理器通常检查回调接口，或者它可能用代理包装一个 bean。一些 Spring AOP 基础设施类就是通过实现 bean 后处理器来提供代理包装逻辑的。

`ApplicationContext` 会自动检测配置元数据中定义的所有实现了 `BeanPostProcessor` 接口的 bean。`ApplicationContext` 将这些 bean 注册为后处理器，以便在创建 bean 时调用。bean 后处理器可以像其他 bean 一样部署到容器中。

请注意，当使用配置类中的 `@Bean` 工厂方法声明一个 `BeanPostProcessor` 时，工厂方法的返回类型应为实现类本身或至少为 `org.springframework.beans.factory.config.BeanPostProcessor` 接口，以清楚地表明该 bean 是后处理器。否则，`ApplicationContext` 无法在完全创建之前通过类型自动检测到它。由于 `BeanPostProcessor` 需要提前实例化，以便应用于上下文中的其他 bean 的初始化，因此这种早期类型检测至关重要。

[[beans-factory-programmatically-registering-beanpostprocessors]]
.程序化注册 `BeanPostProcessor` 实例
注意：虽然推荐的 `BeanPostProcessor` 注册方法是通过 `ApplicationContext` 自动检测（如前文所述），但您也可以通过使用 `ConfigurableBeanFactory` 的 `addBeanPostProcessor` 方法以编程方式注册它们。当您需要在注册之前评估条件逻辑，甚至在层次结构中跨上下文复制 bean 后处理器时，这可能很有用。但是，请注意，程序化添加的 `BeanPostProcessor` 实例不尊重 `Ordered` 接口。在这里，注册顺序决定了执行顺序。还要注意的是，程序化注册的 `BeanPostProcessor` 实例始终在通过自动检测注册的那些之前处理，而不考虑任何显式排序。

.`BeanPostProcessor` 实例和 AOP 自动代理
[NOTE]
====
实现 `BeanPostProcessor` 接口的类是特殊的，容器会对它们进行不同的处理。所有 `BeanPostProcessor` 实例及其直接引用的 bean 都会在启动时作为 `ApplicationContext` 的特殊启动阶段的一部分进行实例化。接下来，所有 `BeanPostProcessor` 实例将按排序方式注册，并应用于容器中的所有后续 bean。由于 AOP 自动代理本身是作为 `BeanPostProcessor` 实现的，因此既不对 `BeanPostProcessor` 实例也不对它们直接引用的 bean 进行自动代理处理，因此不会将切面织入其中。

对于任何这样的 bean，您应该会看到一条信息日志消息：`Bean someBean 不适合通过所有 BeanPostProcessor 接口进行处理（例如：不适合自动代理）`。

如果您通过自动装配或 `@Resource`（可能会回退到自动装配）将 bean 注入您的 `BeanPostProcessor` 中，Spring 可能会在搜索类型匹配的依赖候选项时访问意外的 bean，从而使它们不适合进行自动代理或其他类型的 bean 后处理。例如，如果您有一个使用 `@Resource` 注释的依赖项，其中字段或 setter 的名称与 bean 的声明名称不直接对应并且未使用名称属性，Spring 会访问其他 bean 以按类型匹配它们。
====

以下示例展示了如何在 `ApplicationContext` 中编写、注册和使用 `BeanPostProcessor` 实例。

[[beans-factory-extension-bpp-examples-hw]]
==== 示例：Hello World，`BeanPostProcessor` 风格

这个第一个示例说明了基本用法。示例展示了一个自定义 `BeanPostProcessor` 实现，它在容器创建每个 bean 时调用 `toString()` 方法，并将生成的字符串打印到系统控制台。

以下列表显示了自定义 `BeanPostProcessor` 实现类定义：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	package scripting;

	import org.springframework.beans.factory.config.BeanPostProcessor;

	public class InstantiationTracingBeanPostProcessor implements BeanPostProcessor {

		// simply return the instantiated bean as-is
		public Object postProcessBeforeInitialization(Object bean, String beanName) {
			return bean; // we could potentially return any object reference here...
		}

		public Object postProcessAfterInitialization(Object bean, String beanName) {
			System.out.println("Bean '" + beanName + "' created : " + bean.toString());
			return bean;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.beans.factory.config.BeanPostProcessor

	class InstantiationTracingBeanPostProcessor : BeanPostProcessor {

		// simply return the instantiated bean as-is
		override fun postProcessBeforeInitialization(bean: Any, beanName: String): Any? {
			return bean // we could potentially return any object reference here...
		}

		override fun postProcessAfterInitialization(bean: Any, beanName: String): Any? {
			println("Bean '$beanName' created : $bean")
			return bean
		}
	}
----

以下 `beans` 元素使用 `InstantiationTracingBeanPostProcessor`：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:lang="http://www.springframework.org/schema/lang"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/lang
			https://www.springframework.org/schema/lang/spring-lang.xsd">

		<lang:groovy id="messenger"
				script-source="classpath:org/springframework/scripting/groovy/Messenger.groovy">
			<lang:property name="message" value="Fiona Apple Is Just So Dreamy."/>
		</lang:groovy>

		<!--
		when the above bean (messenger) is instantiated, this custom
		BeanPostProcessor implementation will output the fact to the system console
		-->
		<bean class="scripting.InstantiationTracingBeanPostProcessor"/>

	</beans>
----

请注意，`InstantiationTracingBeanPostProcessor` 只是被定义出来。它甚至没有名称，并且因为它是一个 bean，所以可以像其他 bean 一样进行依赖注入。（前面的配置还定义了一个由 Groovy 脚本支持的 bean。Spring 动态语言支持的详细信息见标题为 <<languages.adoc#dynamic-language, Dynamic Language Support>> 的章节。）

以下 Java 应用程序运行前面的代码和配置：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import org.springframework.context.ApplicationContext;
	import org.springframework.context.support.ClassPathXmlApplicationContext;
	import org.springframework.scripting.Messenger;

	public final class Boot {

		public static void main(final String[] args) throws Exception {
			ApplicationContext ctx = new ClassPathXmlApplicationContext("scripting/beans.xml");
			Messenger messenger = ctx.getBean("messenger", Messenger.class);
			System.out.println(messenger);
		}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
    import org.springframework.beans.factory.getBean

	fun main() {
		val ctx = ClassPathXmlApplicationContext("scripting/beans.xml")
		val messenger = ctx.getBean<Messenger>("messenger")
		println(messenger)
	}
----

前面应用程序的输出类似于以下内容：

[literal,subs="verbatim,quotes"]
----
Bean 'messenger' created : org.springframework.scripting.groovy.GroovyMessenger@272961
org.springframework.scripting.groovy.GroovyMessenger@272961
----

[[beans-factory-extension-bpp-examples-aabpp]]
==== 示例：`AutowiredAnnotationBeanPostProcessor`

结合回调接口或注解以及自定义 `BeanPostProcessor` 实现是扩展 Spring IoC 容器的一种常见方法。一个例子是 Spring 的 `AutowiredAnnotationBeanPostProcessor`——一个随 Spring 发行版一起提供的 `BeanPostProcessor` 实现，用于自动装配带有注解的字段、setter 方法和任意配置方法。

[[beans-factory-extension-factory-postprocessors]]
=== 使用 `BeanFactoryPostProcessor` 自定义配置元数据

下一个我们要探讨的扩展点是 `org.springframework.beans.factory.config.BeanFactoryPostProcessor`。这个接口的语义与 `BeanPostProcessor` 类似，但有一个主要区别：`BeanFactoryPostProcessor` 作用于 bean 的配置元数据。也就是说，Spring IoC 容器允许 `BeanFactoryPostProcessor` 在容器实例化任何 bean 之前读取配置元数据并可能更改它，除了 `BeanFactoryPostProcessor` 实例。

您可以配置多个 `BeanFactoryPostProcessor` 实例，并且可以通过设置 `order` 属性来控制这些 `BeanFactoryPostProcessor` 实例的运行顺序。然而，只有当 `BeanFactoryPostProcessor` 实现了 `Ordered` 接口时，您才能设置此属性。如果您编写自己的 `BeanFactoryPostProcessor`，您也应该考虑实现 `Ordered` 接口。有关更多详细信息，请参阅 {api-spring-framework}/beans/factory/config/BeanFactoryPostProcessor.html[`BeanFactoryPostProcessor`] 和 {api-spring-framework}/core/Ordered.html[`Ordered`] 接口的 javadoc。

[NOTE]
====
如果您想更改实际的 bean 实例（即从配置元数据创建的对象），那么您需要使用 `BeanPostProcessor`（如 <<beans-factory-extension-bpp>> 中所述）。虽然在 `BeanFactoryPostProcessor` 中处理 bean 实例在技术上是可能的（例如，通过使用 `BeanFactory.getBean()`），但这样做会导致 bean 的提前实例化，违反标准容器生命周期。这可能会导致负面影响，如绕过 bean 后处理。

此外，`BeanFactoryPostProcessor` 实例是按容器范围划分的。仅当您使用容器层次结构时，这一点才有意义。如果您在一个容器中定义了一个 `BeanFactoryPostProcessor`，它只对该容器中的 bean 定义进行后处理。在一个容器中定义的 bean 定义不会被另一个容器中的 `BeanFactoryPostProcessor` 实例后处理，即使这两个容器是同一层次结构的一部分。
====

当 `ApplicationContext` 内声明了一个 bean 工厂后处理器时，它会自动运行，以应用对定义容器的配置元数据的更改。Spring 包含了许多预定义的 bean 工厂后处理器，如 `PropertyOverrideConfigurer` 和 `PropertySourcesPlaceholderConfigurer`。您也可以使用自定义的 `BeanFactoryPostProcessor`，例如注册自定义属性编辑器。

`ApplicationContext` 会自动检测部署到其中的实现了 `BeanFactoryPostProcessor` 接口的所有 bean，并在适当的时间将这些 bean 用作 bean 工厂后处理器。您可以像其他 bean 一样部署这些后处理器 bean。

注意：与 ``BeanPostProcessor``s 类似，通常不建议将 ``BeanFactoryPostProcessor`` 配置为延迟初始化。如果没有其他 bean 引用了 `Bean(Factory)PostProcessor`，则该后处理器将根本不会被实例化。因此，将其标记为延迟初始化将被忽略，并且即使您在 `<beans />` 元素的声明中将 `default-lazy-init` 属性设置为 `true`，`Bean(Factory)PostProcessor` 也会被迫切地实例化。

[[beans-factory-placeholderconfigurer]]
==== 示例：类名替换 `PropertySourcesPlaceholderConfigurer`

您可以使用 `PropertySourcesPlaceholderConfigurer` 将属性值从 bean 定义外部化到一个单独的文件中，使用标准的 Java `Properties` 格式。这样做使应用程序的部署人员能够定制环境特定的属性，如数据库 URL 和密码，而无需修改容器的主 XML 定义文件或文件。

请考虑以下基于 XML 的配置元数据片段，其中定义了具有占位符值的 `DataSource`：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean class="org.springframework.context.support.PropertySourcesPlaceholderConfigurer">
		<property name="locations" value="classpath:com/something/jdbc.properties"/>
	</bean>

	<bean id="dataSource" destroy-method="close"
			class="org.apache.commons.dbcp.BasicDataSource">
		<property name="driverClassName" value="${jdbc.driverClassName}"/>
		<property name="url" value="${jdbc.url}"/>
		<property name="username" value="${jdbc.username}"/>
		<property name="password" value="${jdbc.password}"/>
	</bean>
----

该示例展示了从外部 `Properties` 文件配置的属性。在运行时，`PropertySourcesPlaceholderConfigurer` 应用于元数据，替换了一些 DataSource 的属性。这些要替换的值以占位符的形式指定，格式为 `${property-name}`，这与 Ant、log4j 和 JSP EL 风格一致。

实际值来自标准 Java `Properties` 格式的另一个文件：

[literal,subs="verbatim,quotes"]
----
jdbc.driverClassName=org.hsqldb.jdbcDriver
jdbc.url=jdbc:hsqldb:hsql://production:9002
jdbc.username=sa
jdbc.password=root
----

因此，`${jdbc.username}` 字符串在运行时被替换为值 'sa'，并且对于与属性文件中键匹配的其他占位符值也是如此。`PropertySourcesPlaceholderConfigurer` 检查 bean 定义的大多数属性和属性中的占位符。此外，您还可以自定义占位符前缀和后缀。

在 Spring 2.5 引入的 `context` 命名空间中，您可以使用专用的配置元素配置属性占位符。您可以在 `location` 属性中以逗号分隔的列表形式提供一个或多个位置，如以下示例所示：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<context:property-placeholder location="classpath:com/something/jdbc.properties"/>
----

`PropertySourcesPlaceholderConfigurer` 不仅查找您指定的 `Properties` 文件中的属性。默认情况下，如果在指定的属性文件中找不到属性，它会检查 Spring `Environment` 属性和常规 Java `System` 属性。

[TIP]
=====
您可以使用 `PropertySourcesPlaceholderConfigurer` 替换类名，这在您需要在运行时选择特定的实现类时非常有用。以下示例展示了如何进行操作：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean class="org.springframework.beans.factory.config.PropertySourcesPlaceholderConfigurer">
		<property name="locations">
			<value>classpath:com/something/strategy.properties</value>
		</property>
		<property name="properties">
			<value>custom.strategy.class=com.something.DefaultStrategy</value>
		</property>
	</bean>

	<bean id="serviceStrategy" class="${custom.strategy.class}"/>
----

如果在运行时无法将类解析为有效类，则在 `ApplicationContext` 的 `preInstantiateSingletons()` 阶段，bean 即将被创建时解析失败。
=====

[[beans-factory-overrideconfigurer]]
==== 示例：`PropertyOverrideConfigurer`

`PropertyOverrideConfigurer` 是另一个 bean 工厂后处理器，与 `PropertySourcesPlaceholderConfigurer` 类似，但与后者不同的是，原始定义可以有默认值或完全没有属性值。如果覆盖的 `Properties` 文件中没有某个 bean 属性的条目，则使用默认上下文定义。

请注意，bean 定义并不知道自己被覆盖了，因此从 XML 定义文件中并不明显看出使用了覆盖配置器。如果多个 `PropertyOverrideConfigurer` 实例为同一 bean 属性定义了不同的值，最后一个会获胜，因为它覆盖了之前的设置。

属性文件的配置行采用以下格式：

[literal,subs="verbatim,quotes"]
----
beanName.property=value
----

以下列表显示了该格式的一个示例：

[literal,subs="verbatim,quotes"]
----
dataSource.driverClassName=com.mysql.jdbc.Driver
dataSource.url=jdbc:mysql:mydb
----

此示例文件可以与包含名为 `dataSource` 且具有 `driver` 和 `url` 属性的容器定义一起使用。

也支持复合属性名，只要路径的每个组件（除了最终被覆盖的属性）已经是非空的（大概由构造函数初始化）。在以下示例中，`tom` bean 的 `fred` 属性的 `bob` 属性的 `sammy` 属性被设置为标量值 `123`：

[literal,subs="verbatim,quotes"]
----
tom.fred.bob.sammy=123
----

注意：指定的覆盖值始终为字面值。它们不会被翻译为 bean 引用。这种约定也适用于 XML bean 定义中的原始值指定为 bean 引用的情况。

在 Spring 2.5 引入的 `context` 命名空间中，可以使用专用的配置元素配置属性覆盖，如以下示例所示：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<context:property-override location="classpath:override.properties"/>
----



[[aware-list]]
=== 其他 `Aware` 接口

除了 `ApplicationContextAware` 和 `BeanNameAware`（前面讨论过 <<beans-factory-aware, earlier>>），
Spring 提供了多种 `Aware` 回调接口，允许 bean 向容器表明它们需要某些基础设施依赖。一般来说，接口名称表明了依赖类型。下表总结了最重要的 `Aware` 接口：

[[beans-factory-nature-aware-list]]
.Aware 接口
|===
| 名称 | 注入的依赖 | 详细解释

| `ApplicationContextAware`
| 声明的 `ApplicationContext`。
| <<beans-factory-aware>>

| `ApplicationEventPublisherAware`
| 包含 `ApplicationContext` 的事件发布器。
| <<context-introduction>>

| `BeanClassLoaderAware`
| 加载 bean 类的类加载器。
| <<beans-factory-class>>

| `BeanFactoryAware`
| 声明的 `BeanFactory`。
| <<beans-beanfactory>>

| `BeanNameAware`
| 声明的 bean 的名称。
| <<beans-factory-aware>>

| `LoadTimeWeaverAware`
| 用于在加载时处理类定义的编织器。
| <<aop-aj-ltw>>

| `MessageSourceAware`
| 配置的消息解析策略（支持参数化和国际化）。
| <<context-introduction>>

| `NotificationPublisherAware`
| Spring JMX 通知发布器。
| <<integration.adoc#jmx-notifications, Notifications>>

| `ResourceLoaderAware`
| 配置的资源加载器，用于低级访问资源。
| <<resources>>

| `ServletConfigAware`
| 容器运行时的当前 `ServletConfig`。仅在支持 web 的 Spring `ApplicationContext` 中有效。
| <<web.adoc#mvc, Spring MVC>>

| `ServletContextAware`
| 容器运行时的当前 `ServletContext`。仅在支持 web 的 Spring `ApplicationContext` 中有效。
| <<web.adoc#mvc, Spring MVC>>
|===

再次注意，使用这些接口将代码绑定到 Spring API，不遵循控制反转的风格。因此，我们建议仅将它们用于需要编程访问容器的基础设施 bean。

[[beans-child-bean-definitions]]
== Bean 定义继承

一个 bean 定义可以包含大量的配置信息，包括构造函数参数、属性值和容器特定的信息，如初始化方法、静态工厂方法名等。子 bean 定义从父定义继承配置信息。子定义可以根据需要覆盖一些值或添加其他值。使用父子 bean 定义可以节省大量的输入。实际上，这是一种模板化的形式。

如果您以编程方式使用 `ApplicationContext` 接口，子 bean 定义由 `ChildBeanDefinition` 类表示。大多数用户不会在这种级别上使用它们，而是通过在 `ClassPathXmlApplicationContext` 这样的类中声明性地配置 bean 定义。当您使用基于 XML 的配置元数据时，可以通过使用 `parent` 属性来指示子 bean 定义，并将父 bean 作为该属性的值。以下示例显示了如何执行此操作：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<bean id="inheritedTestBean" abstract="true"
        class="org.springframework.beans.TestBean">
    <property name="name" value="parent"/>
    <property name="age" value="1"/>
</bean>

<bean id="inheritsWithDifferentClass"
        class="org.springframework.beans.DerivedTestBean"
        parent="inheritedTestBean" init-method="initialize">  <1>
    <property name="name" value="override"/>
    <!-- age 属性值 1 将从父级继承 -->
</bean>
----
<1> 注意 `parent` 属性。

如果没有指定子 bean 定义，则使用父定义中的 bean 类，但也可以覆盖它。在后一种情况下，子 bean 类必须与父类兼容（即，它必须接受父类的属性值）。

子 bean 定义继承作用域、构造函数参数值、属性值和方法覆盖，可以选择添加新值。您指定的任何作用域、初始化方法、销毁方法或 `static` 工厂方法设置都会覆盖相应的父设置。

其余设置始终从子定义中获取：依赖项、自动装配模式、依赖检查、单例和延迟初始化。

前面的示例通过使用 `abstract` 属性显式地将父 bean 定义标记为抽象的。如果父定义未指定类，则需要显式将父 bean 定义标记为 `abstract`，如以下示例所示：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<bean id="inheritedTestBeanWithoutClass" abstract="true">
    <property name="name" value="parent"/>
    <property name="age" value="1"/>
</bean>

<bean id="inheritsWithClass" class="org.springframework.beans.DerivedTestBean"
        parent="inheritedTestBeanWithoutClass" init-method="initialize">
    <property name="name" value="override"/>
    <!-- age 将继承父 bean 定义中的值 1 -->
</bean>
----

父 bean 无法单独实例化，因为它是不完整的，并且明确标记为 `abstract`。当定义为 `abstract` 时，它只能用作纯模板 bean 定义，用于为子定义服务。尝试单独使用这种 `abstract` 父 bean，通过将其作为另一个 bean 的 ref 属性或通过显式 `getBean()` 调用父 bean ID 会返回错误。同样，容器的内部 `preInstantiateSingletons()` 方法忽略定义为抽象的 bean 定义。

注意：默认情况下，`ApplicationContext` 会预实例化所有单例。因此，至少对于单例 bean，如果您有一个（父）bean 定义，您只打算将其用作模板，并且此定义指定了类，则必须确保将 __abstract__ 属性设置为 __true__，否则应用程序上下文实际上会（尝试）预实例化 `abstract` bean。

[[beans-factory-extension]]
== 容器扩展点

通常，应用程序开发人员不需要子类化 `ApplicationContext` 实现类。相反，Spring IoC 容器可以通过插入特殊集成接口的实现来扩展。接下来的几个部分将介绍这些集成接口。

[[beans-factory-extension-bpp]]
=== 使用 `BeanPostProcessor` 自定义 Bean

`BeanPostProcessor` 接口定义了回调方法，您可以实现这些方法以提供您自己的（或覆盖容器的默认）实例化逻辑、依赖解析逻辑等。如果您想在 Spring 容器完成实例化、配置和初始化 bean 后实现一些自定义逻辑，您可以插入一个或多个自定义 `BeanPostProcessor` 实现。

您可以配置多个 `BeanPostProcessor` 实例，并且可以通过设置 `order` 属性来控制这些 `BeanPostProcessor` 实例的运行顺序。仅当 `BeanPostProcessor` 实现了 `Ordered` 接口时，您才能设置此属性。如果您编写自己的 `BeanPostProcessor`，您也应该考虑实现 `Ordered` 接口。有关详细信息，请参阅 {api-spring-framework}/beans/factory/config/BeanPostProcessor.html[`BeanPostProcessor`] 和 {api-spring-framework}/core/Ordered.html[`Ordered`] 接口的 Javadoc。另请参阅有关 <<beans-factory-programmatically-registering-beanpostprocessors, 以编程方式注册 `BeanPostProcessor` 实例>> 的说明。

[NOTE]
====
`BeanPostProcessor` 实例作用于 bean（或对象）实例。也就是说，Spring IoC 容器实例化一个 bean 实例，然后 `BeanPostProcessor` 实例开始工作。

`BeanPostProcessor` 实例在每个容器中都是独立的。这仅在您使用容器层次结构时相关。如果您在一个容器中定义了一个 `BeanPostProcessor`，它只会后处理该容器中的 bean。换句话说，在一个容器中定义的 bean 不会被定义在另一个容器中的 `BeanPostProcessor` 后处理，即使这两个容器属于同一层次结构。

要更改实际的 bean 定义（即，定义 bean 的蓝图），则需要使用 `BeanFactoryPostProcessor`，如 <<beans-factory-extension-factory-postprocessors>> 中所述。
====

`org.springframework.beans.factory.config.BeanPostProcessor` 接口包含两个回调方法。当这样的类注册为容器的后处理器时，对于由容器创建的每个 bean 实例，后处理器都会在容器初始化方法（如 `InitializingBean.afterPropertiesSet()` 或任何声明的 `init` 方法）之前和之后获得容器的回调。后处理器可以对 bean 实例执行任何操作，包括完全忽略回调。bean 后处理器通常会检查回调接口，或者它可能会使用代理包装 bean。一些 Spring AOP 基础设施类作为 bean 后处理器实现，以提供代理包装逻辑。

`ApplicationContext` 会自动检测配置元数据中定义的实现了 `BeanPostProcessor` 接口的任何 bean。`ApplicationContext` 将这些 bean 注册为后处理器，以便在创建 bean 时调用它们。bean 后处理器可以像任何其他 bean 一样部署在容器中。

注意，当使用配置类上的 `@Bean` 工厂方法声明 `BeanPostProcessor` 时，工厂方法的返回类型应为实现类本身或至少是 `org.springframework.beans.factory.config.BeanPostProcessor` 接口，明确表明该 bean 的后处理器性质。否则，`ApplicationContext` 无法在完全创建之前通过类型自动检测它。由于 `BeanPostProcessor` 需要在早期实例化，以便应用于上下文中的其他 bean 的初始化，因此这种早期类型检测至关重要。

[[beans-factory-programmatically-registering-beanpostprocessors]]
.以编程方式注册 `BeanPostProcessor` 实例
注意：虽然通过 `ApplicationContext` 自动检测（如前所述）是注册 `BeanPostProcessor` 的推荐方法，但您可以通过使用 `addBeanPostProcessor` 方法以编程方式将它们注册到 `ConfigurableBeanFactory`。当您需要在注册之前评估条件逻辑时，或者甚至为了在层次结构中的上下文之间复制 bean 后处理器时，这可能很有用。然而，以编程方式添加的 `BeanPostProcessor` 实例不遵循 `Ordered` 接口。在这里，注册顺序决定了执行顺序。还要注意，程序化注册的 `BeanPostProcessor` 实例始终在那些通过自动检测注册的实例之前处理，无论是否存在明确的排序。

.`BeanPostProcessor` 实例与 AOP 自动代理
[NOTE]
====
实现 `BeanPostProcessor` 接口的类是特殊的，并且容器对它们的处理方式不同。所有 `BeanPostProcessor` 实例及其直接引用的 bean 都会在启动时实例化，作为 `ApplicationContext` 的特殊启动阶段的一部分。接下来，所有 `BeanPostProcessor` 实例将按排序注册，并应用于容器中的所有其他 bean。由于 AOP 自动代理本身就是作为 `BeanPostProcessor` 实现的，因此 `BeanPostProcessor` 实例及其直接引用的 bean 不会被自动代理，因此也不会被编织成切面。

对于任何此类 bean，您应该看到一条信息日志消息：`Bean someBean 不符合所有 BeanPostProcessor 接口的处理条件（例如：不符合自动代理的条件）`。

如果您通过自动装配或 `@Resource`（可能会回退到自动装配）将 bean 连接到您的 `BeanPostProcessor`，Spring 可能会在搜索类型匹配的依赖项候选者时访问意外的 bean，从而使它们不符合自动代理或其他类型的 bean 后处理的条件。例如，如果您有一个注释了 `@Resource` 的依赖项，其中字段或 setter 名称与声明的 bean 名称不直接对应，并且未使用名称属性，Spring 会访问其他 bean 以匹配它们的类型。
====

以下示例展示了如何在 `ApplicationContext` 中编写、注册和使用 `BeanPostProcessor` 实例。

[[beans-factory-extension-bpp-examples-hw]]
==== 示例：Hello World，`BeanPostProcessor` 风格

第一个示例说明了基本用法。该示例显示了一个自定义 `BeanPostProcessor` 实现，该实现会在容器创建 bean 时调用每个 bean 的 `toString()` 方法，并将生成的字符串打印到系统控制台。

以下清单显示了自定义 `BeanPostProcessor` 实现类的定义：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
package scripting;

import org.springframework.beans.factory.config.BeanPostProcessor;

public class InstantiationTracingBeanPostProcessor implements BeanPostProcessor {

    // 直接返回实例化的 bean
    public Object postProcessBeforeInitialization(Object bean, String beanName) {
        return bean; // 我们可以在这里返回任何对象引用...
    }

    public Object postProcessAfterInitialization(Object bean, String beanName) {
        System.out.println("Bean '" + beanName + "' created : " + bean.toString());
        return bean;
    }
}
----

以下 `beans` 元素使用了 `InstantiationTracingBeanPostProcessor`：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:lang="http://www.springframework.org/schema/lang"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/lang
        https://www.springframework.org/schema/lang/spring-lang.xsd">

    <lang:groovy id="messenger"
            script-source="classpath:org/springframework/scripting/groovy/Messenger.groovy">
        <lang:property name="message" value="Fiona Apple Is Just So Dreamy."/>
    </lang:groovy>

    <!--
    当上面的 bean（messenger）实例化时，这个自定义
    BeanPostProcessor 实现会将事实输出到系统控制台
    -->
    <bean class="scripting.InstantiationTracingBeanPostProcessor"/>

</beans>
----

注意，`InstantiationTracingBeanPostProcessor` 只是定义了它。它甚至没有名称，并且由于它是一个 bean，因此可以像任何其他 bean 一样进行依赖注入。（前面的配置还定义了一个由 Groovy 脚本支持的 bean。Spring 动态语言支持的详细信息，请参阅 <<languages.adoc#dynamic-language, 动态语言支持>> 章节。）

以下 Java 应用程序运行上述代码和配置：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.scripting.Messenger;

public final class Boot {

    public static void main(final String[] args) throws Exception {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("scripting/beans.xml");
        Messenger messenger = ctx.getBean("messenger", Messenger.class);
        System.out.println(messenger);
    }

}
----

该应用程序的输出类似于以下内容：

[literal,subs="verbatim,quotes"]
----
Bean 'messenger' created : org.springframework.scripting.groovy.GroovyMessenger@272961
org.springframework.scripting.groovy.GroovyMessenger@272961
----

[[beans-factory-extension-bpp-examples-aabpp]]
==== 示例：`AutowiredAnnotationBeanPostProcessor`

在使用自定义 `BeanPostProcessor` 实现时，结合回调接口或注释是扩展 Spring IoC 容器的常用方法。例如，Spring 的 `AutowiredAnnotationBeanPostProcessor` 就是一个与 Spring 一起发布的 `BeanPostProcessor` 实现，它会自动装配带有注释的字段、setter 方法和任意配置方法。

[[beans-factory-extension-factory-postprocessors]]
=== 使用 `BeanFactoryPostProcessor` 自定义配置元数据

接下来我们要介绍的扩展点是 `org.springframework.beans.factory.config.BeanFactoryPostProcessor`。该接口的语义与 `BeanPostProcessor` 类似，但有一个主要区别：`BeanFactoryPostProcessor` 作用于 bean 配置元数据。也就是说，Spring IoC 容器允许 `BeanFactoryPostProcessor` 读取配置元数据，并在容器实例化任何 bean 之前可能更改它（除了 `BeanFactoryPostProcessor` 实例之外）。

您可以配置多个 `BeanFactoryPostProcessor` 实例，并且可以通过设置 `order` 属性来控制这些 `BeanFactoryPostProcessor` 实例的运行顺序。然而，只有当 `BeanFactoryPostProcessor` 实现了 `Ordered` 接口时，您才能设置此属性。如果您编写自己的 `BeanFactoryPostProcessor`，您也应该考虑实现 `Ordered` 接口。有关详细信息，请参阅 {api-spring-framework}/beans/factory/config/BeanFactoryPostProcessor.html[`BeanFactoryPostProcessor`] 和 {api-spring-framework}/core/Ordered.html[`Ordered`] 接口的 Javadoc。

[NOTE]
====
如果您想更改实际的 bean 实例（即，从配置元数据创建的对象），那么您需要使用 `BeanPostProcessor`（如前面在 <<beans-factory-extension-bpp>> 中所述）。虽然在 `BeanFactoryPostProcessor` 中处理 bean 实例在技术上是可能的（例如，使用 `BeanFactory.getBean()`），但这样做会导致提前实例化 bean，违反标准的容器生命周期。这可能会导致负面影响，如绕过 bean 后处理。

此外，`BeanFactoryPostProcessor` 实例在每个容器中都是独立的。这仅在您使用容器层次结构时相关。如果您在一个容器中定义了一个 `BeanFactoryPostProcessor`，它只会应用于该容器中的 bean 定义。一个容器中的 bean 定义不会被另一个容器中的 `BeanFactoryPostProcessor` 实例后处理，即使这两个容器属于同一层次结构。
====

在 `ApplicationContext` 中声明的 bean 工厂后处理器会自动运行，以应用对定义容器的配置元数据的更改。Spring 包含许多预定义的 bean 工厂后处理器，如 `PropertyOverrideConfigurer` 和 `PropertySourcesPlaceholderConfigurer`。您还可以使用自定义 `BeanFactoryPostProcessor`，例如，注册自定义属性编辑器。

`ApplicationContext` 会自动检测部署到其中的实现 `BeanFactoryPostProcessor` 接口的任何 bean。它会在适当的时候将这些 bean 用作 bean 工厂后处理器。您可以像部署任何其他 bean 一样部署这些后处理器 bean。

注意：与 ``BeanPostProcessor`` 类似，通常不建议为 `BeanFactoryPostProcessor` 配置延迟初始化。如果没有其他 bean 引用 `Bean(Factory)PostProcessor`，则该后处理器根本不会被实例化。因此，将其标记为延迟初始化将被忽略，并且即使您在 `<beans />` 元素的声明上将 `default-lazy-init` 属性设置为 `true`，`Bean(Factory)PostProcessor` 也会被提前实例化。

[[beans-factory-placeholderconfigurer]]
==== 示例：类名替换 `PropertySourcesPlaceholderConfigurer`

您可以使用 `PropertySourcesPlaceholderConfigurer` 将 bean 定义中的属性值外部化到单独的文件中，使用标准的 Java `Properties` 格式。这样可以让应用程序的部署者定制特定环境的属性，如数据库 URL 和密码，而不需要修改主 XML 定义文件或容器的多个文件，降低了复杂性和风险。

考虑以下基于 XML 的配置元数据片段，其中定义了一个带有占位符值的 `DataSource`：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<bean class="org.springframework.context.support.PropertySourcesPlaceholderConfigurer">
    <property name="locations" value="classpath:com/something/jdbc.properties"/>
</bean>

<bean id="dataSource" destroy-method="close"
        class="org.apache.commons.dbcp.BasicDataSource">
    <property name="driverClassName" value="${jdbc.driverClassName}"/>
    <property name="url" value="${jdbc.url}"/>
    <property name="username" value="${jdbc.username}"/>
    <property name="password" value="${jdbc.password}"/>
</bean>
----

该示例显示了从外部 `Properties` 文件配置的属性。在运行时，将 `PropertySourcesPlaceholderConfigurer` 应用于元数据，替换 `DataSource` 的某些属性。要替换的值指定为格式为 pass:q[`${property-name}`] 的占位符，遵循 Ant、log4j 和 JSP EL 风格。

实际值来自标准 Java `Properties` 格式的另一个文件：

[literal,subs="verbatim,quotes"]
----
jdbc.driverClassName=org.hsqldb.jdbcDriver
jdbc.url=jdbc:hsqldb:hsql://production:9002
jdbc.username=sa
jdbc.password=root
----

因此，`${jdbc.username}` 字符串在运行时被替换为值 'sa'，其他与属性文件中键匹配的占位符值也是如此。`PropertySourcesPlaceholderConfigurer` 会检查 bean 定义的大多数属性和属性中的占位符。此外，您还可以自定义占位符的前缀和后缀。

在 Spring 2.5 引入的 `context` 命名空间中，您可以使用专用配置元素配置属性占位符。您可以在 `location` 属性中提供一个或多个位置，作为逗号分隔的列表，如以下示例所示：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<context:property-placeholder location="classpath:com/something/jdbc.properties"/>
----

`PropertySourcesPlaceholderConfigurer` 不仅会查找您指定的 `Properties` 文件中的属性。默认情况下，如果它无法在指定的属性文件中找到某个属性，它会检查 Spring `Environment` 属性和常规的 Java `System` 属性。

[TIP]
=====
您可以使用 `PropertySourcesPlaceholderConfigurer` 替换类名，当您需要在运行时选择特定实现类时，这有时很有用。以下示例展示了如何执行此操作：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<bean class="org.springframework.beans.factory.config.PropertySourcesPlaceholderConfigurer">
    <property name="locations">
        <value>classpath:com/something/strategy.properties</value>
    </property>
    <property name="properties">
        <value>custom.strategy.class=com.something.DefaultStrategy</value>
    </property>
</bean>

<bean id="serviceStrategy" class="${custom.strategy.class}"/>
----

如果在运行时无法将类解析为有效类，则在即将创建 bean 时解析失败，即对于非延迟初始化的 bean，在 `preInstantiateSingletons()` 阶段。
=====

[[beans-factory-overrideconfigurer]]
==== 示例：`PropertyOverrideConfigurer`

`PropertyOverrideConfigurer` 是另一个 bean 工厂后处理器，类似于 `PropertySourcesPlaceholderConfigurer`，但与后者不同的是，原始定义可以为 bean 属性设置默认值或不设置值。如果覆盖的 `Properties` 文件中没有某个 bean 属性的条目，则使用默认的上下文定义。

请注意，bean 定义并不知道被覆盖，因此在 XML 定义文件中不明显使用了覆盖配置器。如果多个 `PropertyOverrideConfigurer` 实例为同一 bean 属性定义了不同的值，则最后一个胜出，这取决于覆盖机制。

属性文件配置行采用以下格式：

[literal,subs="verbatim,quotes"]
----
beanName.property=value
----

以下清单显示了该格式的一个示例：

[literal,subs="verbatim,quotes"]
----
dataSource.driverClassName=com.mysql.jdbc.Driver
dataSource.url=jdbc:mysql:mydb
----

此示例文件可与包含名为 `dataSource` 的 bean 的容器定义一起使用，该 bean 具有 `driver` 和 `url` 属性。

也支持复合属性名称，只要路径中的每个组件（除了最后一个被覆盖的属性）已经是非空的（可能由构造函数初始化）。在以下示例中，`tom` bean 的 `fred` 属性的 `bob` 属性的 `sammy` 属性被设置为标量值 `123`：

[literal,subs="verbatim,quotes"]
----
tom.fred.bob.sammy=123
----

注意：指定的覆盖值始终是字面值。它们不会被翻译为 bean 引用。这一惯例也适用于 XML bean 定义中指定为 bean 引用的原始值。

在 Spring 2.5 引入的 `context` 命名空间中，可以使用专用配置元素配置属性覆盖，如以下示例所示：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<context:property-override location="classpath:override.properties"/>
----



[[beans-resource-annotation]]
=== 使用 `@Resource` 进行注入

Spring 也支持使用 JSR-250 的 `@Resource` 注解（`javax.annotation.Resource`）在字段或 bean 属性的 setter 方法上进行注入。
这是 Java EE 中的常见模式，例如在 JSF 管理的 bean 和 JAX-WS 端点中。Spring 支持这种模式用于 Spring 管理的对象。

`@Resource` 接受一个 name 属性。默认情况下，Spring 将该值解释为要注入的 bean 名称。换句话说，它遵循按名称的语义，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Resource(name="myMovieFinder") // <1>
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
}
----
<1> 这一行通过 `@Resource` 注入。

如果没有显式指定名称，默认名称是从字段名或 setter 方法派生的。对于字段，它采用字段名。对于 setter 方法，它采用 bean 属性名。以下示例将会在 setter 方法中注入名为 `movieFinder` 的 bean：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Resource
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
}
----

NOTE: 注解中提供的名称由 `ApplicationContext` 解析，`CommonAnnotationBeanPostProcessor` 可以识别该名称。
如果你显式配置 Spring 的 {api-spring-framework}/jndi/support/SimpleJndiBeanFactory.html[`SimpleJndiBeanFactory`]，则可以通过 JNDI 解析名称。然而，我们建议你依赖默认行为，并使用 Spring 的 JNDI 查找功能来保持间接性。

在仅使用 `@Resource` 且未指定显式名称的特殊情况下，与 `@Autowired` 类似，`@Resource` 会首先找到主要类型匹配，而不是特定的命名 bean，并解析已知的可解析依赖项：`BeanFactory`、`ApplicationContext`、`ResourceLoader`、`ApplicationEventPublisher` 和 `MessageSource` 接口。

因此，在以下示例中，`customerPreferenceDao` 字段首先会查找名为 "customerPreferenceDao" 的 bean，然后回退到主要类型匹配 `CustomerPreferenceDao`：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
public class MovieRecommender {

    @Resource
    private CustomerPreferenceDao customerPreferenceDao;

    @Resource
    private ApplicationContext context; // <1>

    public MovieRecommender() {
    }

    // ...
}
----
<1> `context` 字段是基于已知的可解析依赖项类型 `ApplicationContext` 进行注入的。


[[beans-value-annotations]]
=== 使用 `@Value`

`@Value` 通常用于注入外部化的属性：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Component
public class MovieRecommender {

    private final String catalog;

    public MovieRecommender(@Value("${catalog.name}") String catalog) {
        this.catalog = catalog;
    }
}
----

使用以下配置：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Configuration
@PropertySource("classpath:application.properties")
public class AppConfig { }
----

以及以下 `application.properties` 文件：

[source,java,indent=0,subs="verbatim,quotes"]
----
catalog.name=MovieCatalog
----

在这种情况下，`catalog` 参数和字段将等于 `MovieCatalog` 的值。

Spring 提供了一个默认的宽松嵌入值解析器。它会尝试解析属性值，如果无法解析，则属性名（例如 `${catalog.name}`）将被注入为值。如果你想严格控制不存在的值，你应该声明一个 `PropertySourcesPlaceholderConfigurer` bean，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Configuration
public class AppConfig {

    @Bean
    public static PropertySourcesPlaceholderConfigurer propertyPlaceholderConfigurer() {
        return new PropertySourcesPlaceholderConfigurer();
    }
}
----

NOTE: 当使用 JavaConfig 配置 `PropertySourcesPlaceholderConfigurer` 时，`@Bean` 方法必须是 `static` 的。

使用上述配置可以确保 Spring 初始化失败，如果任何 `${}` 占位符无法解析。也可以使用 `setPlaceholderPrefix`、`setPlaceholderSuffix` 或 `setValueSeparator` 方法来自定义占位符。

NOTE: Spring Boot 默认配置了一个 `PropertySourcesPlaceholderConfigurer` bean，它将从 `application.properties` 和 `application.yml` 文件中获取属性。

Spring 提供的内置转换器支持允许简单类型转换（例如转换为 `Integer` 或 `int`）自动处理。多个逗号分隔的值可以自动转换为 `String` 数组，而无需额外的努力。

可以按如下方式提供一个默认值：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Component
public class MovieRecommender {

    private final String catalog;

    public MovieRecommender(@Value("${catalog.name:defaultCatalog}") String catalog) {
        this.catalog = catalog;
    }
}
----

Spring `BeanPostProcessor` 在后台使用 `ConversionService` 来处理将 `@Value` 中的 `String` 值转换为目标类型的过程。如果你想为自己的自定义类型提供转换支持，可以提供自己的 `ConversionService` bean 实例，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Configuration
public class AppConfig {

    @Bean
    public ConversionService conversionService() {
        DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService();
        conversionService.addConverter(new MyCustomConverter());
        return conversionService;
    }
}
----

当 `@Value` 包含 <<expressions, `SpEL` 表达式>> 时，该值将在运行时动态计算，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Component
public class MovieRecommender {

    private final String catalog;

    public MovieRecommender(@Value("#{systemProperties['user.catalog'] + 'Catalog' }") String catalog) {
        this.catalog = catalog;
    }
}
----

SpEL 还支持使用更复杂的数据结构：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Component
public class MovieRecommender {

    private final Map<String, Integer> countOfMoviesPerCatalog;

    public MovieRecommender(
            @Value("#{{'Thriller': 100, 'Comedy': 300}}") Map<String, Integer> countOfMoviesPerCatalog) {
        this.countOfMoviesPerCatalog = countOfMoviesPerCatalog;
    }
}
----


[[beans-postconstruct-and-predestroy-annotations]]
=== 使用 `@PostConstruct` 和 `@PreDestroy`

`CommonAnnotationBeanPostProcessor` 不仅识别 `@Resource` 注解，还识别 JSR-250 生命周期注解：`javax.annotation.PostConstruct` 和 `javax.annotation.PreDestroy`。这些注解在 Spring 2.5 中引入，提供了生命周期回调机制的替代方案，如 <<beans-factory-lifecycle-initializingbean, 初始化回调>> 和 <<beans-factory-lifecycle-disposablebean, 销毁回调>> 中描述的那样。只要 `CommonAnnotationBeanPostProcessor` 在 Spring `ApplicationContext` 中注册，带有这些注解的方法就会在生命周期的相同阶段被调用，与对应的 Spring 生命周期接口方法或显式声明的回调方法一样。在下面的例子中，缓存将在初始化时预填充，并在销毁时清除：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
public class CachingMovieLister {

    @PostConstruct
    public void populateMovieCache() {
        // 初始化时填充电影缓存...
    }

    @PreDestroy
    public void clearMovieCache() {
        // 销毁时清除电影缓存...
    }
}
----

有关组合各种生命周期机制的影响的详细信息，请参见 <<beans-factory-lifecycle-combined-effects>>。

[NOTE]
====
与 `@Resource` 一样，`@PostConstruct` 和 `@PreDestroy` 注解类型是 JDK 6 到 8 标准 Java 库的一部分。然而，`javax.annotation` 包在 JDK 9 中被从核心 Java 模块中分离，并最终在 JDK 11 中被移除。如果需要，必须通过 Maven Central 获取 `javax.annotation-api` 工件，并像其他库一样添加到应用程序的类路径中。
====

[[beans-classpath-scanning]]
== 类路径扫描和管理组件

本章中的大多数示例使用 XML 来指定在 Spring 容器内生成每个 `BeanDefinition` 的配置元数据。上一节 (<<beans-annotation-config>>) 演示了如何通过源级注解提供大量配置元数据。然而，即使在那些示例中，"base" bean 定义也在 XML 文件中显式定义，而注解仅用于驱动依赖注入。本节描述了一种通过扫描类路径隐式检测候选组件的选项。候选组件是与过滤标准匹配的类，并且有相应的 bean 定义注册到容器中。这消除了使用 XML 执行 bean 注册的需要。相反，你可以使用注解（例如 `@Component`）、AspectJ 类型表达式或自定义过滤标准来选择哪些类有 bean 定义注册到容器中。

[NOTE]
====
从 Spring 3.0 开始，Spring JavaConfig 项目提供的许多功能已成为核心 Spring 框架的一部分。这使你可以使用 Java 定义 bean，而不是使用传统的 XML 文件。查看 `@Configuration`、`@Bean`、`@Import` 和 `@DependsOn` 注解，了解如何使用这些新功能。
====

[[beans-stereotype-annotations]]
=== `@Component` 和其他模式注解

`@Repository` 注解是用于标记任何履行存储库（也称为数据访问对象或 DAO）角色或模式的类的标记之一。此标记的用途之一是自动翻译异常，如 <<data-access.adoc#orm-exception-translation, 异常翻译>> 中所述。

Spring 提供了其他模式注解：`@Component`、`@Service` 和 `@Controller`。`@Component` 是任何 Spring 管理组件的通用模式注解。`@Repository`、`@Service` 和 `@Controller` 是 `@Component` 的特化，分别用于更具体的用例（在持久层、服务层和表示层中）。因此，你可以使用 `@Component` 来注解组件类，但通过使用 `@Repository`、`@Service` 或 `@Controller` 注解它们，你的类更适合工具处理或与切面关联。例如，这些模式注解是理想的切入点目标。`@Repository`、`@Service` 和 `@Controller` 还可以在 Spring 框架的未来版本中携带其他语义。因此，如果你在为服务层选择使用 `@Component` 还是 `@Service` 之间做选择，`@Service` 显然是更好的选择。同样，正如前面所述，`@Repository` 已经作为持久层中自动异常翻译的标记得到支持。

[[beans-meta-annotations]]
=== 使用元注解和组合注解

Spring 提供的许多注解可以作为元注解在你的代码中使用。元注解是可以应用于另一个注解的注解。例如，前面提到的 `@Service` 注解在 <<beans-stereotype-annotations, 之前>> 被 `@Component` 元注解化，如下例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component // <1>
public @interface Service {

    // ...
}
----
<1> `@Component` 使 `@Service` 被视为与 `@Component` 相同。

你还可以组合元注解来创建“组合注解”。例如，Spring MVC 的 `@RestController` 注解是由 `@Controller` 和 `@ResponseBody` 组合而成的。

此外，组合注解还可以选择性地重新声明元注解的属性，以允许自定义。当你只想暴露元注解的一部分属性时，这尤其有用。例如，Spring 的 `@SessionScope` 注解将范围名称硬编码为 `session`，但仍然允许自定义 `proxyMode`。以下列表显示了 `SessionScope` 注解的定义：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Scope(WebApplicationContext.SCOPE_SESSION)
public @interface SessionScope {

    /**
     * {@link Scope#proxyMode} 的别名。
     * <p>默认为 {@link ScopedProxyMode#TARGET_CLASS}。
     */
    @AliasFor(annotation = Scope.class)
    ScopedProxyMode proxyMode() default ScopedProxyMode.TARGET_CLASS;

}
----

然后，你可以在不声明 `proxyMode` 的情况下使用 `@SessionScope`，如下所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Service
@SessionScope
public class SessionScopedService {
    // ...
}
----

你还可以重写 `proxyMode` 的值，如下例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Service
@SessionScope(proxyMode = ScopedProxyMode.INTERFACES)
public class SessionScopedUserService implements UserService {
    // ...
}
----

有关详细信息，请参见
https://github.com/spring-projects/spring-framework/wiki/Spring-Annotation-Programming-Model[Spring 注解编程模型]
wiki 页面。



[[beans-scanning-autodetection]]
=== 自动检测类并注册 Bean 定义

Spring 可以自动检测标记了特定注解的类，并将相应的 `BeanDefinition` 实例注册到 `ApplicationContext` 中。例如，以下两个类符合这样的自动检测条件：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Service
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    public SimpleMovieLister(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
}
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Repository
public class JpaMovieFinder implements MovieFinder {
    // 为了清晰，省略了实现部分
}
----

要自动检测这些类并注册相应的 bean，你需要在 `@Configuration` 类中添加 `@ComponentScan`，其中 `basePackages` 属性是两个类的共同父包。（或者，你可以指定一个以逗号、分号或空格分隔的列表，包含每个类的父包。）

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Configuration
@ComponentScan(basePackages = "org.example")
public class AppConfig  {
    // ...
}
----

NOTE: 为简洁起见，前面的示例可以使用注解的 `value` 属性（即 `@ComponentScan("org.example")`）。

以下是使用 XML 的替代方案：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd">

    <context:component-scan base-package="org.example"/>

</beans>
----

TIP: 使用 `<context:component-scan>` 会隐式启用 `<context:annotation-config>` 的功能。使用 `<context:component-scan>` 时，通常不需要包含 `<context:annotation-config>` 元素。

[NOTE]
====
类路径包的扫描需要在类路径中存在相应的目录条目。当你使用 Ant 构建 JAR 时，确保没有激活 JAR 任务的仅文件开关。此外，在某些环境中，基于安全策略可能无法暴露类路径目录——例如，在 JDK 1.7.0_45 及更高版本的独立应用程序中（这需要在你的 manifest 文件中设置 'Trusted-Library'——参见 https://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources）。

在 JDK 9 的模块路径（Jigsaw）上，Spring 的类路径扫描通常按预期工作。然而，确保在你的 `module-info` 描述符中导出了组件类。如果你希望 Spring 调用类的非公开成员，确保它们是“打开的”（即在 `module-info` 描述符中使用 `opens` 声明而不是 `exports` 声明）。
====

此外，`AutowiredAnnotationBeanPostProcessor` 和 `CommonAnnotationBeanPostProcessor` 在使用组件扫描元素时会被隐式包含。这意味着这两个组件会自动检测并连接在一起——完全不需要通过 XML 提供任何 bean 配置元数据。

NOTE: 你可以通过在注解中包含 `annotation-config` 属性并设置为 `false` 来禁用 `AutowiredAnnotationBeanPostProcessor` 和 `CommonAnnotationBeanPostProcessor` 的注册。

[[beans-scanning-filters]]
=== 使用过滤器自定义扫描

默认情况下，仅带有 `@Component`、`@Repository`、`@Service`、`@Controller`、`@Configuration` 注解或自身带有 `@Component` 注解的自定义注解的类才会被检测为候选组件。然而，你可以通过应用自定义过滤器来修改和扩展此行为。可以将它们添加为 `@ComponentScan` 注解的 `includeFilters` 或 `excludeFilters` 属性（或在 XML 配置中作为 `<context:include-filter />` 或 `<context:exclude-filter />` 子元素）。每个过滤器元素都需要 `type` 和 `expression` 属性。下表描述了过滤选项：

[[beans-scanning-filters-tbl]]
.Filter Types
|===
| 过滤器类型| 示例表达式| 描述

| annotation (默认)
| `org.example.SomeAnnotation`
| 在目标组件的类型级别存在或元存在的注解。

| assignable
| `org.example.SomeClass`
| 目标组件可分配的类（或接口）（扩展或实现）。

| aspectj
| `org.example..*Service+`
| 目标组件应匹配的 AspectJ 类型表达式。

| regex
| `org\.example\.Default.*`
| 目标组件的类名应匹配的正则表达式。

| custom
| `org.example.MyTypeFilter`
| `org.springframework.core.type.TypeFilter` 接口的自定义实现。
|===

以下示例展示了忽略所有 `@Repository` 注解并使用“`stub`”存储库的配置：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Configuration
@ComponentScan(basePackages = "org.example",
        includeFilters = @Filter(type = FilterType.REGEX, pattern = ".*Stub.*Repository"),
        excludeFilters = @Filter(Repository.class))
public class AppConfig {
    // ...
}
----

以下是等效的 XML 配置：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<beans>
    <context:component-scan base-package="org.example">
        <context:include-filter type="regex"
                expression=".*Stub.*Repository"/>
        <context:exclude-filter type="annotation"
                expression="org.springframework.stereotype.Repository"/>
    </context:component-scan>
</beans>
----

NOTE: 你还可以通过在注解中设置 `useDefaultFilters=false` 或在 `<component-scan/>` 元素中提供 `use-default-filters="false"` 属性来禁用默认过滤器。这实际上禁用了 `@Component`、`@Repository`、`@Service`、`@Controller`、`@RestController` 或 `@Configuration` 注解或元注解的类的自动检测。

[[beans-factorybeans-annotations]]
=== 在组件中定义 Bean 元数据

Spring 组件还可以向容器贡献 bean 定义元数据。你可以使用与在 `@Configuration` 注解类中定义 bean 元数据相同的 `@Bean` 注解来实现此目的。以下示例展示了如何做到这一点：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Component
public class FactoryMethodComponent {

    @Bean
    @Qualifier("public")
    public TestBean publicInstance() {
        return new TestBean("publicInstance");
    }

    public void doWork() {
        // 省略了组件方法的实现
    }
}
----

前面的类是一个 Spring 组件，其 `doWork()` 方法中包含特定于应用程序的代码。然而，它还贡献了一个 bean 定义，该定义具有一个工厂方法，指向 `publicInstance()` 方法。`@Bean` 注解标识工厂方法和其他 bean 定义属性，例如通过 `@Qualifier` 注解指定的限定符值。可以指定的其他方法级别注解包括 `@Scope`、`@Lazy` 和自定义限定符注解。

TIP: 除了组件初始化的作用外，你还可以将 `@Lazy` 注解放在标记为 `@Autowired` 或 `@Inject` 的注入点上。在这种情况下，它会导致注入一个延迟解析代理。然而，这种代理方法相对有限。对于复杂的延迟交互，特别是在结合可选依赖项时，我们推荐使用 `ObjectProvider<MyTargetBean>`。

支持自动装配的字段和方法，如前面讨论的那样，同时还支持 `@Bean` 方法的自动装配。以下示例展示了如何做到这一点：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Component
public class FactoryMethodComponent {

    private static int i;

    @Bean
    @Qualifier("public")
    public TestBean publicInstance() {
        return new TestBean("publicInstance");
    }

    // 使用自定义限定符和方法参数的自动装配
    @Bean
    protected TestBean protectedInstance(
            @Qualifier("public") TestBean spouse,
            @Value("#{privateInstance.age}") String country) {
        TestBean tb = new TestBean("protectedInstance", 1);
        tb.setSpouse(spouse);
        tb.setCountry(country);
        return tb;
    }

    @Bean
    private TestBean privateInstance() {
        return new TestBean("privateInstance", i++);
    }

    @Bean
    @RequestScope
    public TestBean requestScopedInstance() {
        return new TestBean("requestScopedInstance", 3);
    }
}
----

示例中将 `String` 方法参数 `country` 自动装配为另一个名为 `privateInstance` 的 bean 的 `age` 属性值。通过 `#{ <expression> }` 表示法，Spring 表达式语言元素定义了属性值。对于 `@Value` 注解，表达式解析器预配置为在解析表达式文本时查找 bean 名称。

自 Spring Framework 4.3 起，你还可以声明类型为 `InjectionPoint`（或其更具体的子类 `DependencyDescriptor`）的工厂方法参数，以访问触发当前 bean 创建的请求注入点。请注意，这仅适用于实际创建 bean 实例的情况，而不适用于现有实例的注入。因此，此功能对于原型范围的 bean 最有意义。对于其他范围，工厂方法只会看到在给定范围内触发新 bean 实例创建的注入点（例如，触发延迟单例 bean 创建的依赖项）。你可以在这些场景中谨慎使用提供的注入点元数据。以下示例展示了如何使用 `InjectionPoint`：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Component
public class FactoryMethodComponent {

    @Bean @Scope("prototype")
    public TestBean prototypeInstance(InjectionPoint injectionPoint) {
        return new TestBean("prototypeInstance for " + injectionPoint.getMember());
    }
}
----

常规 Spring 组件中的 `@Bean` 方法与 Spring `@Configuration` 类中的同类方法处理方式不同。区别在于 `@Component` 类不会通过 CGLIB 进行增强，以拦截方法和字段的调用。CGLIB 代理是通过调用 `@Configuration` 类中的 `@Bean` 方法或字段来创建与协作对象的 bean 元数据引用的方式。此类方法不按正常的 Java 语义调用，而是通过容器调用，以便提供 Spring bean 的常规生命周期管理和代理，即使是通过对 `@Bean` 方法的编程调用引用其他 bean 时也是如此。相比之下，在普通 `@Component` 类中的 `@Bean` 方法中调用方法或字段具有标准的 Java 语义，不存在特殊的 CGLIB 处理或其他约束。

[NOTE]
====
你可以将 `@Bean` 方法声明为 `static`，这样可以在不创建其包含的配置类实例的情况下调用它们。这在定义后处理器 bean（例如，类型为 `BeanFactoryPostProcessor` 或 `BeanPostProcessor` 的 bean）时特别有意义，因为这些 bean 在容器生命周期的早期被初始化，应避免在该点触发配置的其他部分。

对静态 `@Bean` 方法的调用永远不会被容器拦截，即使是在 `@Configuration` 类中（如本节前面所述），这是由于技术限制：CGLIB 子类化只能重写非静态方法。因此，直接调用另一个 `@Bean` 方法具有标准的 Java 语义，直接从工厂方法本身返回一个独立实例。

`@Bean` 方法的 Java 语言可见性对 Spring 容器中生成的 bean 定义没有直接影响。你可以自由地在非 `@Configuration` 类中声明你的工厂方法，也可以在任何地方声明静态方法。然而，`@Configuration` 类中的常规 `@Bean` 方法需要是可重写的——也就是说，它们不能声明为 `private` 或 `final`。

`@Bean` 方法也会在给定组件或配置类的基类上被发现，以及在组件或配置类实现的接口中声明的 Java 8 默认方法上被发现。这为组合复杂的配置安排提供了极大的灵活性，甚至通过 Spring 4.2 支持的 Java 8 默认方法实现多重继承。

最后，一个类可以为同一个 bean 持有多个 `@Bean` 方法，作为根据运行时可用依赖项使用的多个工厂方法的安排。这与在其他配置场景中选择“最贪婪”构造函数或工厂方法的算法相同：在构造时选择可满足依赖项数量最多的变体，类似于容器在多个 `@Autowired` 构造函数之间进行选择的方式。
====


[[beans-scanning-name-generator]]
=== 为自动检测到的组件命名

当组件在扫描过程中被自动检测到时，其 bean 名称是由该扫描器已知的 `BeanNameGenerator` 策略生成的。默认情况下，任何包含名称 `value` 的 Spring 模式注解（`@Component`、`@Repository`、`@Service` 和 `@Controller`）都会将该名称提供给相应的 bean 定义。

如果这样的注解不包含名称 `value`，或者对于其他任何检测到的组件（例如通过自定义过滤器发现的组件），默认的 bean 名称生成器将返回未大写的非限定类名。例如，如果检测到以下组件类，名称将是 `myMovieLister` 和 `movieFinderImpl`：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Service("myMovieLister")
public class SimpleMovieLister {
    // ...
}
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Repository
public class MovieFinderImpl implements MovieFinder {
    // ...
}
----

如果你不想依赖默认的 bean 命名策略，可以提供一个自定义的 bean 命名策略。首先，实现 {api-spring-framework}/beans/factory/support/BeanNameGenerator.html[`BeanNameGenerator`] 接口，并确保包含一个默认的无参构造函数。然后，在配置扫描器时提供完全限定的类名，如以下示例注解和 bean 定义所示。

TIP: 如果由于多个自动检测到的组件具有相同的非限定类名（即，名称相同但位于不同包中的类）而遇到命名冲突，可能需要配置一个 `BeanNameGenerator`，使其默认使用完全限定类名作为生成的 bean 名称。从 Spring Framework 5.2.3 开始，可以使用位于 `org.springframework.context.annotation` 包中的 `FullyQualifiedAnnotationBeanNameGenerator` 来实现此目的。

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Configuration
@ComponentScan(basePackages = "org.example", nameGenerator = MyNameGenerator.class)
public class AppConfig {
    // ...
}
----

[source,xml,indent=0,subs="verbatim,quotes"]
----
<beans>
    <context:component-scan base-package="org.example"
        name-generator="org.example.MyNameGenerator" />
</beans>
----

作为一般规则，建议在注解中指定名称，以便在其他组件可能对其进行显式引用时使用。另一方面，自动生成的名称在容器负责连接时通常是足够的。

[[beans-scanning-scope-resolver]]
=== 为自动检测到的组件提供作用域

与 Spring 管理的组件一样，自动检测到的组件的默认且最常见的作用域是 `singleton`。然而，有时你需要一个可以通过 `@Scope` 注解指定的不同作用域。你可以在注解中提供作用域的名称，如下例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Scope("prototype")
@Repository
public class MovieFinderImpl implements MovieFinder {
    // ...
}
----

NOTE: `@Scope` 注解仅在具体的 bean 类（对于带注解的组件）或工厂方法（对于 `@Bean` 方法）上进行检查。与 XML bean 定义不同，这里没有 bean 定义继承的概念，类级别的继承层次结构与元数据无关。

有关 Spring 上下文中 Web 特定作用域（如 "`request`" 或 "`session`"）的详细信息，请参见 <<beans-factory-scopes-other>>。与这些作用域的预构建注解一样，你还可以使用 Spring 的元注解方法来组合自己的作用域注解：例如，一个用 `@Scope("prototype")` 元注解的自定义注解，可能还声明了一个自定义的作用域代理模式。

NOTE: 如果希望提供自定义的作用域解析策略，而不是依赖基于注解的方法，你可以实现 {api-spring-framework}/context/annotation/ScopeMetadataResolver.html[`ScopeMetadataResolver`] 接口。确保包含一个默认的无参构造函数。然后可以在配置扫描器时提供完全限定的类名，如以下示例注解和 bean 定义所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Configuration
@ComponentScan(basePackages = "org.example", scopeResolver = MyScopeResolver.class)
public class AppConfig {
    // ...
}
----

[source,xml,indent=0,subs="verbatim,quotes"]
----
<beans>
    <context:component-scan base-package="org.example" scope-resolver="org.example.MyScopeResolver"/>
</beans>
----

在使用某些非单例作用域时，可能需要为这些作用域的对象生成代理。原因在 <<beans-factory-scopes-other-injection>> 中进行了描述。为此，组件扫描元素上提供了一个作用域代理属性。该属性有三个可能的值：`no`、`interfaces` 和 `targetClass`。例如，以下配置会生成标准的 JDK 动态代理：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Configuration
@ComponentScan(basePackages = "org.example", scopedProxy = ScopedProxyMode.INTERFACES)
public class AppConfig {
    // ...
}
----

[source,xml,indent=0,subs="verbatim,quotes"]
----
<beans>
    <context:component-scan base-package="org.example" scoped-proxy="interfaces"/>
</beans>
----

[[beans-scanning-qualifiers]]
=== 使用注解提供限定符元数据

`@Qualifier` 注解在 <<beans-autowired-annotation-qualifiers>> 中进行了讨论。该节中的示例演示了如何使用 `@Qualifier` 注解和自定义限定符注解来提供细粒度的控制，以便在解析自动装配候选项时使用。由于这些示例是基于 XML bean 定义的，因此限定符元数据是通过在 XML 中的 `bean` 元素的 `qualifier` 或 `meta` 子元素上提供的。当依赖类路径扫描进行组件的自动检测时，可以通过在候选类上使用类型级别的注解来提供限定符元数据。以下三个示例演示了这种技术：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Component
@Qualifier("Action")
public class ActionMovieCatalog implements MovieCatalog {
    // ...
}
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Component
@Genre("Action")
public class ActionMovieCatalog implements MovieCatalog {
    // ...
}
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Component
@Offline
public class CachingMovieCatalog implements MovieCatalog {
    // ...
}
----

NOTE: 与大多数基于注解的替代方案一样，请记住注解元数据绑定到类定义本身，而使用 XML 时，多个相同类型的 bean 可以在其限定符元数据上提供变体，因为该元数据是按实例而非按类提供的。

[[beans-scanning-index]]
=== 生成候选组件的索引

尽管类路径扫描非常快速，但通过在编译时创建候选项的静态列表，可以提高大型应用程序的启动性能。在这种模式下，作为组件扫描目标的所有模块都必须使用这种机制。

NOTE: 现有的 `@ComponentScan` 或 `<context:component-scan/>` 指令必须保持不变，以请求上下文在某些包中扫描候选项。当 `ApplicationContext` 检测到这样的索引时，它会自动使用该索引，而不是扫描类路径。

要生成索引，请为包含作为组件扫描目标的组件的每个模块添加一个附加依赖项。以下示例展示了如何使用 Maven 实现这一点：

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
<dependencies>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context-indexer</artifactId>
        <version>{spring-version}</version>
        <optional>true</optional>
    </dependency>
</dependencies>
----

在 Gradle 4.5 及更早版本中，应在 `compileOnly` 配置中声明该依赖项，如以下示例所示：

[source,groovy,indent=0,subs="verbatim,quotes,attributes"]
----
dependencies {
    compileOnly "org.springframework:spring-context-indexer:{spring-version}"
}
----

在 Gradle 4.6 及更高版本中，应在 `annotationProcessor` 配置中声明该依赖项，如以下示例所示：

[source,groovy,indent=0,subs="verbatim,quotes,attributes"]
----
dependencies {
    annotationProcessor "org.springframework:spring-context-indexer:{spring-version}"
}
----

`spring-context-indexer` 工件会生成一个 `META-INF/spring.components` 文件，并将其包含在 jar 文件中。

NOTE: 在 IDE 中使用此模式时，必须将 `spring-context-indexer` 注册为注解处理器，以确保在更新候选组件时索引是最新的。

TIP: 当在类路径上找到 `META-INF/spring.components` 文件时，索引会自动启用。如果索引部分可用于某些库（或用例），但无法为整个应用程序构建，可以通过设置 `spring.index.ignore` 为 `true` 来回退到常规类路径安排（就像根本没有索引一样），这可以通过 JVM 系统属性或通过 <<appendix.adoc#appendix-spring-properties,`SpringProperties`>> 机制实现。

[[beans-standard-annotations]]
== 使用 JSR 330 标准注解

从 Spring 3.0 开始，Spring 提供了对 JSR-330 标准注解（依赖注入）的支持。这些注解的扫描方式与 Spring 注解相同。要使用它们，需要将相关的 jar 添加到类路径中。

[NOTE]
=====
如果你使用 Maven，`javax.inject` 工件可以在标准 Maven 仓库中找到（
https://repo1.maven.org/maven2/javax/inject/javax.inject/1/[https://repo1.maven.org/maven2/javax/inject/javax.inject/1/]）。
你可以将以下依赖项添加到你的 pom.xml 文件中：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<dependency>
    <groupId>javax.inject</groupId>
    <artifactId>javax.inject</artifactId>
    <version>1</version>
</dependency>
----
=====

[[beans-inject-named]]
=== 使用 `@Inject` 和 `@Named` 进行依赖注入

你可以使用 `@javax.inject.Inject` 来代替 `@Autowired`，如下所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
import javax.inject.Inject;

public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Inject
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    public void listMovies() {
        this.movieFinder.findMovies(...);
        // ...
    }
}
----

与 `@Autowired` 一样，你可以在字段级别、方法级别和构造函数参数级别使用 `@Inject`。此外，你还可以将注入点声明为 `Provider`，允许通过 `Provider.get()` 调用按需访问较短作用域的 bean 或延迟访问其他 bean。以下示例提供了前面示例的一个变体：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
import javax.inject.Inject;
import javax.inject.Provider;

public class SimpleMovieLister {

    private Provider<MovieFinder> movieFinder;

    @Inject
    public void setMovieFinder(Provider<MovieFinder> movieFinder) {
        this.movieFinder = movieFinder;
    }

    public void listMovies() {
        this.movieFinder.get().findMovies(...);
        // ...
    }
}
----

如果你希望为应注入的依赖项使用限定名称，可以使用 `@Named` 注解，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
import javax.inject.Inject;
import javax.inject.Named;

public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Inject
    public void setMovieFinder(@Named("main") MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}
----

与 `@Autowired` 一样，`@Inject` 也可以与 `java.util.Optional` 或 `@Nullable` 一起使用。这在这里更为适用，因为 `@Inject` 没有 `required` 属性。以下一对示例展示了如何使用 `@Inject` 和 `@Nullable`：

[source,java,indent=0,subs="verbatim,quotes"]
----
public class SimpleMovieLister {

    @Inject
    public void setMovieFinder(Optional<MovieFinder> movieFinder) {
        // ...
    }
}
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
public class SimpleMovieLister {

    @Inject
    public void setMovieFinder(@Nullable MovieFinder movieFinder) {
        // ...
    }
}
----



[[beans-named]]
=== `@Named` 和 `@ManagedBean`: `@Component` 注解的标准等价物

你可以使用 `@javax.inject.Named` 或 `javax.annotation.ManagedBean` 来代替 `@Component`，如下例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
import javax.inject.Inject;
import javax.inject.Named;

@Named("movieListener")  // 也可以使用 @ManagedBean("movieListener")
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Inject
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}
----

通常会在不为组件指定名称的情况下使用 `@Component`。可以以类似的方式使用 `@Named`，如下例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
import javax.inject.Inject;
import javax.inject.Named;

@Named
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Inject
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}
----

当你使用 `@Named` 或 `@ManagedBean` 时，可以像使用 Spring 注解一样使用组件扫描，如下例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Configuration
@ComponentScan(basePackages = "org.example")
public class AppConfig  {
    // ...
}
----

NOTE: 与 `@Component` 不同，JSR-330 `@Named` 和 JSR-250 `@ManagedBean` 注解是不可组合的。你应该使用 Spring 的模式模型来构建自定义组件注解。

[[beans-standard-annotations-limitations]]
=== JSR-330 标准注解的局限性

使用标准注解时，你应该知道一些重要的功能不可用，如下表所示：

[[annotations-comparison]]
.Spring 组件模型元素与 JSR-330 变体的对比
|===
| Spring| javax.inject.*| javax.inject 的限制/评论

| @Autowired
| @Inject
| `@Inject` 没有 'required' 属性。可以与 Java 8 的 `Optional` 一起使用。

| @Component
| @Named / @ManagedBean
| JSR-330 没有提供一个可组合的模型，仅提供一种标识命名组件的方式。

| @Scope("singleton")
| @Singleton
| JSR-330 的默认作用域类似于 Spring 的 `prototype`。然而，为了保持与 Spring 的通用默认值一致，在 Spring 容器中声明的 JSR-330 bean 默认是 `singleton`。如果要使用 `singleton` 以外的作用域，你应该使用 Spring 的 `@Scope` 注解。`javax.inject` 还提供了 https://download.oracle.com/javaee/6/api/javax/inject/Scope.html[@Scope] 注解。然而，这个注解仅用于创建自定义注解。

| @Qualifier
| @Qualifier / @Named
| `javax.inject.Qualifier` 只是一个用于构建自定义限定符的元注解。具体的 `String` 限定符（如带有值的 Spring `@Qualifier`）可以通过 `javax.inject.Named` 关联。

| @Value
| -
| 没有等价物

| @Required
| -
| 没有等价物

| @Lazy
| -
| 没有等价物

| ObjectFactory
| Provider
| `javax.inject.Provider` 是 Spring `ObjectFactory` 的直接替代品，只是有一个更短的 `get()` 方法名。它还可以与 Spring 的 `@Autowired` 一起使用，或与非注解的构造函数和 setter 方法一起使用。
|===

[[beans-java]]
== 基于 Java 的容器配置

本节介绍如何在 Java 代码中使用注解来配置 Spring 容器。包括以下主题：

* <<beans-java-basic-concepts>>
* <<beans-java-instantiating-container>>
* <<beans-java-bean-annotation>>
* <<beans-java-configuration-annotation>>
* <<beans-java-composing-configuration-classes>>
* <<beans-definition-profiles>>
* <<beans-property-source-abstraction>>
* <<beans-using-propertysource>>
* <<beans-placeholder-resolution-in-statements>>

[[beans-java-basic-concepts]]
=== 基本概念: `@Bean` 和 `@Configuration`

Spring 的新 Java 配置支持的核心内容是 `@Configuration` 注解类和 `@Bean` 注解方法。

`@Bean` 注解用于表示一个方法实例化、配置并初始化一个新的对象，该对象由 Spring IoC 容器管理。对于熟悉 Spring 的 `<beans/>` XML 配置的人来说，`@Bean` 注解的作用类似于 `<bean/>` 元素。你可以将 `@Bean` 注解方法与任何 Spring `@Component` 一起使用。然而，它们最常与 `@Configuration` bean 一起使用。

用 `@Configuration` 注解类表示其主要目的是作为 bean 定义的来源。此外，`@Configuration` 类允许通过调用同一类中的其他 `@Bean` 方法来定义 bean 之间的依赖关系。最简单的 `@Configuration` 类如下所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Configuration
public class AppConfig {

    @Bean
    public MyService myService() {
        return new MyServiceImpl();
    }
}
----

上面的 `AppConfig` 类相当于以下 Spring `<beans/>` XML 配置：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<beans>
    <bean id="myService" class="com.acme.services.MyServiceImpl"/>
</beans>
----

.Full @Configuration vs "`lite`" @Bean 模式?
****
当 `@Bean` 方法声明在未使用 `@Configuration` 注解的类中时，它们被认为是在 "`lite`" 模式下处理的。在 `@Component` 或普通类中声明的 bean 方法被视为 "`lite`" 模式，包含类的主要用途不同，`@Bean` 方法在其中有点像一种额外的功能。例如，服务组件可以通过在每个适用的组件类上添加一个额外的 `@Bean` 方法，将管理视图暴露给容器。在这种场景中，`@Bean` 方法是一种通用的工厂方法机制。

与完全的 `@Configuration` 不同，lite `@Bean` 方法不能声明 bean 之间的依赖关系。相反，它们操作的是包含组件的内部状态，并且可以选择性地操作它们可能声明的参数。因此，此类 `@Bean` 方法不应调用其他 `@Bean` 方法。每个这样的方法实际上只是一个特定 bean 引用的工厂方法，没有任何特殊的运行时语义。其积极的副作用是，在运行时不需要应用 CGLIB 子类化，因此在类设计方面没有限制（即，包含类可以是 `final` 等）。

在常见场景中，`@Bean` 方法应声明在 `@Configuration` 类中，以确保始终使用“`full`”模式，并且因此跨方法引用将被重定向到容器的生命周期管理。这可以防止在 "`lite`" 模式下通过常规 Java 调用意外调用同一 `@Bean` 方法，这有助于减少操作 "`lite`" 模式时可能难以追踪的微妙错误。
****

接下来的章节将详细讨论 `@Bean` 和 `@Configuration` 注解。然而，首先，我们介绍使用基于 Java 的配置创建 Spring 容器的各种方法。



[[beans-java-instantiating-container]]
=== 使用 `AnnotationConfigApplicationContext` 实例化 Spring 容器

以下各节记录了 Spring 3.0 引入的 `AnnotationConfigApplicationContext`。这个多功能的 `ApplicationContext` 实现不仅能够接受 `@Configuration` 类作为输入，还可以接受普通的 `@Component` 类和带有 JSR-330 元数据的类。

当 `@Configuration` 类作为输入提供时，`@Configuration` 类本身将被注册为一个 bean 定义，并且该类中声明的所有 `@Bean` 方法也将被注册为 bean 定义。

当提供 `@Component` 和 JSR-330 类时，它们会被注册为 bean 定义，并假定在这些类中根据需要使用了诸如 `@Autowired` 或 `@Inject` 之类的依赖注入元数据。

[[beans-java-instantiating-container-constructor]]
==== 简单构造

与在实例化 `ClassPathXmlApplicationContext` 时使用 Spring XML 文件作为输入的方式类似，你可以在实例化 `AnnotationConfigApplicationContext` 时使用 `@Configuration` 类作为输入。这允许完全不使用 XML 的 Spring 容器，如下例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);
    MyService myService = ctx.getBean(MyService.class);
    myService.doStuff();
}
----

如前所述，`AnnotationConfigApplicationContext` 不仅限于处理 `@Configuration` 类。任何 `@Component` 或带有 JSR-330 注解的类都可以作为输入提供给构造函数，如下例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(MyServiceImpl.class, Dependency1.class, Dependency2.class);
    MyService myService = ctx.getBean(MyService.class);
    myService.doStuff();
}
----

前面的示例假定 `MyServiceImpl`、`Dependency1` 和 `Dependency2` 使用了 Spring 依赖注入注解，例如 `@Autowired`。

[[beans-java-instantiating-container-register]]
==== 使用 `register(Class<?>...)` 编程构建容器

你可以通过使用无参构造函数实例化 `AnnotationConfigApplicationContext`，然后使用 `register()` 方法进行配置。这种方法在编程构建 `AnnotationConfigApplicationContext` 时特别有用。以下示例展示了如何做到这一点：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
public static void main(String[] args) {
    AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
    ctx.register(AppConfig.class, OtherConfig.class);
    ctx.register(AdditionalConfig.class);
    ctx.refresh();
    MyService myService = ctx.getBean(MyService.class);
    myService.doStuff();
}
----

[[beans-java-instantiating-container-scan]]
==== 使用 `scan(String...)` 启用组件扫描

要启用组件扫描，可以按如下方式注解你的 `@Configuration` 类：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Configuration
@ComponentScan(basePackages = "com.acme") // <1>
public class AppConfig  {
    // ...
}
----
<1> 该注解启用组件扫描。

[TIP]
=====
经验丰富的 Spring 用户可能熟悉 Spring `context:` 命名空间中的 XML 声明等效项，如下例所示：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<beans>
    <context:component-scan base-package="com.acme"/>
</beans>
=====
在前面的示例中，扫描 `com.acme` 包以查找任何带有 `@Component` 注解的类，并将这些类注册为容器内的 Spring bean 定义。`AnnotationConfigApplicationContext` 提供 `scan(String...)` 方法以允许相同的组件扫描功能，如下例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
public static void main(String[] args) {
    AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
    ctx.scan("com.acme");
    ctx.refresh();
    MyService myService = ctx.getBean(MyService.class);
}
----

NOTE: 请记住，`@Configuration` 类是使用 `@Component` 进行 <<beans-meta-annotations,元注解>> 的，因此它们是组件扫描的候选对象。在前面的示例中，假设 `AppConfig` 是在 `com.acme` 包（或其下任何包）中声明的，它将在调用 `scan()` 时被拾取。在 `refresh()` 时，所有的 `@Bean` 方法都会被处理并注册为容器中的 bean 定义。

[[beans-java-instantiating-container-web]]
==== 使用 `AnnotationConfigWebApplicationContext` 支持 Web 应用程序

`AnnotationConfigApplicationContext` 的 `WebApplicationContext` 变体可用作 `AnnotationConfigWebApplicationContext`。在配置 Spring `ContextLoaderListener` servlet 监听器、Spring MVC `DispatcherServlet` 等时，可以使用此实现。以下 `web.xml` 片段配置了一个典型的 Spring MVC Web 应用程序（注意 `contextClass` context-param 和 init-param 的使用）：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<web-app>
    <!-- 配置 ContextLoaderListener 使用 AnnotationConfigWebApplicationContext 而不是默认的 XmlWebApplicationContext -->
    <context-param>
        <param-name>contextClass</param-name>
        <param-value>
            org.springframework.web.context.support.AnnotationConfigWebApplicationContext
        </param-value>
    </context-param>

    <!-- 配置位置必须包含一个或多个以逗号或空格分隔的完全限定 @Configuration 类。也可以指定用于组件扫描的完全限定包 -->
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>com.acme.AppConfig</param-value>
    </context-param>

    <!-- 像往常一样使用 ContextLoaderListener 启动根应用程序上下文 -->
    <listener>
        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
    </listener>

    <!-- 像往常一样声明一个 Spring MVC DispatcherServlet -->
    <servlet>
        <servlet-name>dispatcher</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <!-- 配置 DispatcherServlet 使用 AnnotationConfigWebApplicationContext 而不是默认的 XmlWebApplicationContext -->
        <init-param>
            <param-name>contextClass</param-name>
            <param-value>
                org.springframework.web.context.support.AnnotationConfigWebApplicationContext
            </param-value>
        </init-param>
        <!-- 同样，配置位置必须包含一个或多个以逗号或空格分隔并完全限定的 @Configuration 类 -->
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>com.acme.web.MvcConfig</param-value>
        </init-param>
    </servlet>

    <!-- 将所有对 /app/* 的请求映射到 dispatcher servlet -->
    <servlet-mapping>
        <servlet-name>dispatcher</servlet-name>
        <url-pattern>/app/*</url-pattern>
    </servlet-mapping>
</web-app>
----

NOTE: 对于编程用例，可以使用 `GenericWebApplicationContext` 作为 `AnnotationConfigWebApplicationContext` 的替代方案。详情请参阅 {api-spring-framework}/web/context/support/GenericWebApplicationContext.html[`GenericWebApplicationContext`] javadoc。

[[beans-java-bean-annotation]]
=== 使用 `@Bean` 注解

`@Bean` 是方法级注解，是 XML `<bean/>` 元素的直接类比。该注解支持 `<bean/>` 提供的一些属性，例如：

* <<beans-factory-lifecycle-initializingbean, init-method>>
* <<beans-factory-lifecycle-disposablebean, destroy-method>>
* <<beans-factory-autowire,autowiring>>
* `name`。

你可以在带 `@Configuration` 注解的类或带 `@Component` 注解的类中使用 `@Bean` 注解。


[[beans-java-declaring-a-bean]]
==== 声明一个 Bean

要声明一个 bean，可以使用 `@Bean` 注解来标注方法。你可以使用此方法在 `ApplicationContext` 中注册一个 bean 定义，其类型由方法的返回值指定。默认情况下，bean 的名称与方法名称相同。以下示例展示了一个 `@Bean` 方法声明：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Configuration
public class AppConfig {

    @Bean
    public TransferServiceImpl transferService() {
        return new TransferServiceImpl();
    }
}
----

上述配置与以下 Spring XML 完全等效：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<beans>
    <bean id="transferService" class="com.acme.TransferServiceImpl"/>
</beans>
----

这两种声明都在 `ApplicationContext` 中提供了一个名为 `transferService` 的 bean，该 bean 绑定到 `TransferServiceImpl` 类型的对象实例，如下图所示：

[literal,subs="verbatim,quotes"]
----
transferService -> com.acme.TransferServiceImpl
----

你还可以使用默认方法来定义 bean。这允许通过实现带有默认方法的接口来组合 bean 配置。

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
public interface BaseConfig {

    @Bean
    default TransferServiceImpl transferService() {
        return new TransferServiceImpl();
    }
}

@Configuration
public class AppConfig implements BaseConfig {

}
----

你也可以使用接口（或基类）返回类型来声明你的 `@Bean` 方法，如下例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Configuration
public class AppConfig {

    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl();
    }
}
----

然而，这限制了对指定接口类型（`TransferService`）的高级类型预测的可见性，完整类型（`TransferServiceImpl`）只有在受影响的单例 bean 实例化后才会被容器知晓。非懒加载的单例 bean 会根据它们的声明顺序进行实例化，因此你可能会看到不同的类型匹配结果，这取决于其他组件何时尝试按未声明的类型进行匹配（例如 `@Autowired TransferServiceImpl`，只有在 `transferService` bean 实例化后才会解析）。

TIP: 如果你始终通过声明的服务接口引用类型，那么你的 `@Bean` 返回类型也可以安全地遵循这一设计决策。然而，对于实现了多个接口的组件或可能通过其实现类型引用的组件，最好声明尽可能具体的返回类型（至少与引用你的 bean 的注入点所需的类型一样具体）。

[[beans-java-dependencies]]
==== Bean 依赖关系

带有 `@Bean` 注解的方法可以有任意数量的参数，这些参数描述了构建该 bean 所需的依赖关系。例如，如果我们的 `TransferService` 需要一个 `AccountRepository`，我们可以通过方法参数来实现这种依赖关系，如下例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Configuration
public class AppConfig {

    @Bean
    public TransferService transferService(AccountRepository accountRepository) {
        return new TransferServiceImpl(accountRepository);
    }
}
----

这种解析机制与基于构造函数的依赖注入几乎完全相同。有关更多详细信息，请参阅 <<beans-constructor-injection,相关部分>>。

[[beans-java-lifecycle-callbacks]]
==== 接收生命周期回调

任何用 `@Bean` 注解定义的类都支持常规的生命周期回调，并且可以使用 JSR-250 的 `@PostConstruct` 和 `@PreDestroy` 注解。有关详细信息，请参阅 <<beans-postconstruct-and-predestroy-annotations, JSR-250 注解>>。

常规的 Spring <<beans-factory-nature,生命周期>> 回调也完全支持。如果一个 bean 实现了 `InitializingBean`、`DisposableBean` 或 `Lifecycle`，容器将调用它们各自的方法。

一组标准的 `*Aware` 接口（例如 <<beans-beanfactory, BeanFactoryAware>>、<<beans-factory-aware, BeanNameAware>>、<<context-functionality-messagesource, MessageSourceAware>>、<<beans-factory-aware, ApplicationContextAware>> 等）也完全支持。

`@Bean` 注解支持指定任意的初始化和销毁回调方法，就像 Spring XML 中的 `bean` 元素上的 `init-method` 和 `destroy-method` 属性一样，以下示例展示了如何实现：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
public class BeanOne {

    public void init() {
        // 初始化逻辑
    }
}

public class BeanTwo {

    public void cleanup() {
        // 销毁逻辑
    }
}

@Configuration
public class AppConfig {

    @Bean(initMethod = "init")
    public BeanOne beanOne() {
        return new BeanOne();
    }

    @Bean(destroyMethod = "cleanup")
    public BeanTwo beanTwo() {
        return new BeanTwo();
    }
}
----

[NOTE]
=====
默认情况下，使用 Java 配置定义的 bean，如果它们有一个公共的 `close` 或 `shutdown` 方法，会自动加入到销毁回调中。如果你有一个公共的 `close` 或 `shutdown` 方法，并且不希望它在容器关闭时被调用，你可以在你的 bean 定义中添加 `@Bean(destroyMethod="")` 来禁用默认的 `(inferred)` 模式。

对于通过 JNDI 获取的资源，建议默认这样做，因为其生命周期在应用程序之外管理。特别是，确保始终对 `DataSource` 进行此操作，因为已知它在 Java EE 应用服务器上会有问题。

以下示例展示了如何防止 `DataSource` 的自动销毁回调：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Bean(destroyMethod="")
public DataSource dataSource() throws NamingException {
    return (DataSource) jndiTemplate.lookup("MyDS");
}
----

此外，对于 `@Bean` 方法，你通常会使用编程的 JNDI 查找，可以使用 Spring 的 `JndiTemplate` 或 `JndiLocatorDelegate` 助手，或者直接使用 JNDI `InitialContext`，但不会使用 `JndiObjectFactoryBean` 变体（这将迫使你将返回类型声明为 `FactoryBean` 类型，而不是实际的目标类型，这使得在其他打算引用此处提供的资源的 `@Bean` 方法中进行交叉引用调用变得更加困难）。
=====

在上述示例中，`BeanOne` 的 `init()` 方法可以直接在构造过程中调用，如下例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Configuration
public class AppConfig {

    @Bean
    public BeanOne beanOne() {
        BeanOne beanOne = new BeanOne();
        beanOne.init();
        return beanOne;
    }

    // ...
}
----

TIP: 当你直接在 Java 中工作时，可以对你的对象执行任何操作，不必总是依赖容器生命周期。

[[beans-java-specifying-bean-scope]]
==== 指定 Bean 作用域

Spring 包含 `@Scope` 注解，允许你指定 bean 的作用域。

[[beans-java-available-scopes]]
===== 使用 `@Scope` 注解

你可以指定使用 `@Bean` 注解定义的 bean 应具有特定的作用域。可以使用 <<beans-factory-scopes, Bean 作用域>> 部分中指定的任何标准作用域。

默认作用域是 `singleton`，但你可以使用 `@Scope` 注解覆盖此设置，如下例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Configuration
public class MyConfiguration {

    @Bean
    @Scope("prototype")
    public Encryptor encryptor() {
        // ...
    }
}
----

[[beans-java-scoped-proxy]]
===== `@Scope` 和 `scoped-proxy`

Spring 提供了一种方便的方法，通过 <<beans-factory-scopes-other-injection, 作用域代理>> 使用带有作用域的依赖项。在使用 XML 配置时，创建此类代理的最简单方法是 `<aop:scoped-proxy/>` 元素。在 Java 中使用 `@Scope` 注解配置 bean 时，`proxyMode` 属性提供了等效支持。默认值是 `ScopedProxyMode.DEFAULT`，通常表示不应创建作用域代理，除非在组件扫描指令级别配置了不同的默认值。可以指定 `ScopedProxyMode.TARGET_CLASS`、`ScopedProxyMode.INTERFACES` 或 `ScopedProxyMode.NO`。

如果你将 XML 参考文档中的作用域代理示例（请参阅 <<beans-factory-scopes-other-injection, 作用域代理>>）移植到使用 Java 的 `@Bean`，它将类似于以下内容：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
    // 一个 HTTP 会话作用域的 bean，以代理方式暴露
    @Bean
    @SessionScope
    public UserPreferences userPreferences() {
        return new UserPreferences();
    }

    @Bean
    public Service userService() {
        UserService service = new SimpleUserService();
        // 引用代理的 userPreferences bean
        service.setUserPreferences(userPreferences());
        return service;
    }
----

[[beans-java-customizing-bean-naming]]
==== 自定义 Bean 命名

默认情况下，配置类使用 `@Bean` 方法的名称作为生成的 bean 的名称。但是，这一功能可以通过 `name` 属性进行覆盖，如下例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Configuration
public class AppConfig {

    @Bean("myThing")
    public Thing thing() {
        return new Thing();
    }
}
----

[[beans-java-bean-aliasing]]
==== Bean 别名

正如在 <<beans-beanname>> 中讨论的那样，有时希望为单个 bean 提供多个名称，这也称为 bean 别名。`@Bean` 注解的 `name` 属性接受一个字符串数组来实现此目的。以下示例展示了如何为一个 bean 设置多个别名：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Configuration
public class AppConfig {

    @Bean({"dataSource", "subsystemA-dataSource", "subsystemB-dataSource"})
    public DataSource dataSource() {
        // 实例化、配置并返回 DataSource bean...
    }
}
----

[[beans-java-bean-description]]
==== Bean 描述

有时，提供 bean 的更详细文本描述会很有帮助。这在通过 JMX 暴露 bean 以进行监控时特别有用。

要为 `@Bean` 添加描述，可以使用 {api-spring-framework}/context/annotation/Description.html[`@Description`] 注解，如下例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Configuration
public class AppConfig {

    @Bean
    @Description("提供了一个基本的 bean 示例")
    public Thing thing() {
        return new Thing();
    }
}
----

[[beans-java-configuration-annotation]]
=== 使用 `@Configuration` 注解

`@Configuration` 是类级别的注解，表明对象是 bean 定义的来源。`@Configuration` 类通过 `@Bean` 注解的方法声明 bean。调用 `@Configuration` 类中的 `@Bean` 方法还可以定义 bean 之间的依赖关系。有关一般介绍，请参阅 <<beans-java-basic-concepts>>。

[[beans-java-injecting-dependencies]]
==== 注入 Bean 依赖

当 bean 彼此之间存在依赖关系时，表达这种依赖关系的方式就是让一个 bean 方法调用另一个，如下例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Configuration
public class AppConfig {

    @Bean
    public BeanOne beanOne() {
        return new BeanOne(beanTwo());
    }

    @Bean
    public BeanTwo beanTwo() {
        return new BeanTwo();
    }
}
----

在前面的示例中，`beanOne` 通过构造函数注入接收对 `beanTwo` 的引用。

NOTE: 此方法声明 bean 之间的依赖关系仅适用于在 `@Configuration` 类中声明的 `@Bean` 方法。你不能使用普通的 `@Component` 类声明 bean 之间的依赖关系。

[[beans-java-method-injection]]
==== 查找方法注入

如前所述，<<beans-factory-method-injection, 查找方法注入>> 是一个高级特性，应该很少使用。在单例作用域的 bean 依赖于原型作用域的 bean 的情况下，它非常有用。使用 Java 进行此类配置提供了一种实现此模式的自然方式。以下示例展示了如何使用查找方法注入：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
public abstract class CommandManager {
    public Object process(Object commandState) {
        // 获取适当 Command 接口的新实例
        Command command = createCommand();
        // 在（希望是全新的）Command 实例上设置状态
        command.setState(commandState);
        return command.execute();
    }

    // 好吧……但这个方法的实现在哪里？
    protected abstract Command createCommand();
}
----

通过使用 Java 配置，可以创建 `CommandManager` 的子类，其中抽象的 `createCommand()` 方法被覆盖，以便查找新的（原型）命令对象。以下示例展示了如何做到这一点：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Bean
@Scope("prototype")
public AsyncCommand asyncCommand() {
    AsyncCommand command = new AsyncCommand();
    // 根据需要在此处注入依赖关系
    return command;
}

@Bean
public CommandManager commandManager() {
    // 返回 CommandManager 的新匿名实现，其中 createCommand() 被覆盖以返回新的原型 Command 对象
    return new CommandManager() {
        protected Command createCommand() {
            return asyncCommand();
        }
    }
}
----

[[beans-java-further-information-java-config]]
==== 有关 Java 配置工作原理的更多信息

请考虑以下示例，该示例显示了一个 `@Bean` 注解方法被调用两次：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Configuration
public class AppConfig {

    @Bean
    public ClientService clientService1() {
        ClientServiceImpl clientService = new ClientServiceImpl();
        clientService.setClientDao(clientDao());
        return clientService;
    }

    @Bean
    public ClientService clientService2() {
        ClientServiceImpl clientService = new ClientServiceImpl();
        clientService.setClientDao(clientDao());
        return clientService;
    }

    @Bean
    public ClientDao clientDao() {
        return new ClientDaoImpl();
    }
}
----

`clientDao()` 在 `clientService1()` 中调用了一次，在 `clientService2()` 中调用了一次。由于此方法创建了一个新的 `ClientDaoImpl` 实例并返回它，你通常会期望有两个实例（每个服务一个）。这肯定会带来问题：在 Spring 中，实例化的 bean 默认具有 `singleton` 作用域。这就是魔法所在：所有 `@Configuration` 类在启动时都会使用 `CGLIB` 进行子类化。在子类中，子方法首先检查容器中是否有任何缓存（作用域）的 bean，然后再调用父方法并创建一个新实例。

NOTE: 根据 bean 的作用域，行为可能会有所不同。我们这里讨论的是单例。

[NOTE]
====
从 Spring 3.2 开始，不再需要将 CGLIB 添加到类路径中，因为 CGLIB 类已被重新打包到 `org.springframework.cglib` 中，并直接包含在 spring-core JAR 中。
====

[TIP]
====
由于 CGLIB 在启动时动态添加功能，因此存在一些限制。特别是，配置类不能是 final 的。然而，从 4.3 开始，配置类上允许使用任何构造函数，包括使用 `@Autowired` 或用于默认注入的单个非默认构造函数声明。

如果你更喜欢避免任何 CGLIB 强加的限制，请考虑在非 `@Configuration` 类上声明你的 `@Bean` 方法（例如，在普通 `@Component` 类上）。`@Bean` 方法之间的交叉方法调用不会被拦截，因此必须在那里完全依赖构造函数或方法级别的依赖注入。
====



[[beans-java-composing-configuration-classes]]
=== 组合基于 Java 的配置

Spring 的基于 Java 的配置功能让你可以组合注解，从而减少配置的复杂性。

[[beans-java-using-import]]
==== 使用 `@Import` 注解

就像在 Spring XML 文件中使用 `<import/>` 元素来帮助模块化配置一样，`@Import` 注解允许从另一个配置类加载 `@Bean` 定义，如下例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Configuration
public class ConfigA {

    @Bean
    public A a() {
        return new A();
    }
}

@Configuration
@Import(ConfigA.class)
public class ConfigB {

    @Bean
    public B b() {
        return new B();
    }
}
----

现在，不需要在实例化上下文时指定 `ConfigA.class` 和 `ConfigB.class`，只需显式提供 `ConfigB`，如下例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(ConfigB.class);

    // 现在 A 和 B 两个 bean 都可用
    A a = ctx.getBean(A.class);
    B b = ctx.getBean(B.class);
}
----

这种方法简化了容器的实例化过程，因为只需处理一个类，而不是在构造时记住大量 `@Configuration` 类。

TIP: 从 Spring Framework 4.2 开始，`@Import` 还支持引用常规组件类，类似于 `AnnotationConfigApplicationContext.register` 方法。如果你想避免组件扫描，可以使用几个配置类作为入口点来显式定义所有组件，这一点特别有用。

[[beans-java-injecting-imported-beans]]
===== 注入导入的 `@Bean` 定义的依赖关系

前面的示例虽然有效，但比较简单。在大多数实际场景中，bean 之间在配置类之间会有依赖关系。在使用 XML 时，这不是问题，因为没有编译器参与，你可以声明 `ref="someBean"` 并相信 Spring 会在容器初始化期间解决这个问题。但在使用 `@Configuration` 类时，Java 编译器会对配置模型施加约束，即对其他 bean 的引用必须是有效的 Java 语法。

幸运的是，解决这个问题很简单。正如 <<beans-java-dependencies,我们之前讨论过的>>，一个 `@Bean` 方法可以有任意数量的参数，这些参数描述了 bean 的依赖关系。考虑以下更接近实际场景的例子，其中几个 `@Configuration` 类相互依赖：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Configuration
public class ServiceConfig {

    @Bean
    public TransferService transferService(AccountRepository accountRepository) {
        return new TransferServiceImpl(accountRepository);
    }
}

@Configuration
public class RepositoryConfig {

    @Bean
    public AccountRepository accountRepository(DataSource dataSource) {
        return new JdbcAccountRepository(dataSource);
    }
}

@Configuration
@Import({ServiceConfig.class, RepositoryConfig.class})
public class SystemTestConfig {

    @Bean
    public DataSource dataSource() {
        // 返回新的 DataSource
    }
}

public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);
    // 所有配置类之间的依赖关系都会正确连接
    TransferService transferService = ctx.getBean(TransferService.class);
    transferService.transfer(100.00, "A123", "C456");
}
----

实现相同结果还有另一种方法。请记住，`@Configuration` 类最终只不过是容器中的另一个 bean：这意味着它们可以像任何其他 bean 一样利用 `@Autowired` 和 `@Value` 注入等功能。

[WARNING]
====
确保你以这种方式注入的依赖关系仅限于最简单的情况。`@Configuration` 类在上下文初始化过程中处理得相当早，以这种方式强制注入依赖关系可能会导致意外的提前初始化。尽可能使用基于参数的注入，如上例所示。

此外，特别注意通过 `@Bean` 定义 `BeanPostProcessor` 和 `BeanFactoryPostProcessor`。这些通常应声明为 `static @Bean` 方法，以避免触发包含它们的配置类的实例化。否则，由于可能会在 {api-spring-framework}/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html[`AutowiredAnnotationBeanPostProcessor`] 之前创建它作为 bean 实例，`@Autowired` 和 `@Value` 可能无法在配置类本身上工作。
====

以下示例展示了一个 bean 如何被自动注入到另一个 bean 中：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Configuration
public class ServiceConfig {

    @Autowired
    private AccountRepository accountRepository;

    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl(accountRepository);
    }
}

@Configuration
public class RepositoryConfig {

    private final DataSource dataSource;

    public RepositoryConfig(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    @Bean
    public AccountRepository accountRepository() {
        return new JdbcAccountRepository(dataSource);
    }
}

@Configuration
@Import({ServiceConfig.class, RepositoryConfig.class})
public class SystemTestConfig {

    @Bean
    public DataSource dataSource() {
        // 返回新的 DataSource
    }
}

public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);
    // 所有配置类之间的依赖关系都会正确连接
    TransferService transferService = ctx.getBean(TransferService.class);
    transferService.transfer(100.00, "A123", "C456");
}
----

TIP: 构造函数注入在 `@Configuration` 类中从 Spring Framework 4.3 开始支持。此外，如果目标 bean 只定义了一个构造函数，则无需指定 `@Autowired`。

.[[beans-java-injecting-imported-beans-fq]]为方便导航完全限定导入的 bean
--
在前面的场景中，使用 `@Autowired` 非常有效并提供了所需的模块化，但确定自动注入的 bean 定义确切在哪里声明仍然有些模糊。例如，作为查看 `ServiceConfig` 的开发人员，你如何确切地知道 `@Autowired AccountRepository` bean 是在哪里声明的？这在代码中不是显式的，这可能完全没问题。请记住，https://spring.io/tools[Spring Tools for Eclipse] 提供的工具可以渲染图形，显示所有内容是如何连接的，这可能就是你所需要的。此外，你的 Java IDE 也可以轻松查找 `AccountRepository` 类型的所有声明和用法，并快速显示返回该类型的 `@Bean` 方法的位置。

在这种模糊性不可接受且希望在 IDE 中直接导航从一个 `@Configuration` 类到另一个时，可以考虑将配置类本身自动注入。以下示例展示了如何做到这一点：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Configuration
public class ServiceConfig {

    @Autowired
    private RepositoryConfig repositoryConfig;

    @Bean
    public TransferService transferService() {
        // 通过配置类导航到 @Bean 方法！
        return new TransferServiceImpl(repositoryConfig.accountRepository());
    }
}
----

在上述情况下，`AccountRepository` 的定义位置完全明确。然而，`ServiceConfig` 现在与 `RepositoryConfig` 紧密耦合。这就是权衡。这种紧密耦合可以通过使用基于接口或抽象类的 `@Configuration` 类得到一定程度的缓解。请考虑以下示例：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Configuration
public class ServiceConfig {

    @Autowired
    private RepositoryConfig repositoryConfig;

    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl(repositoryConfig.accountRepository());
    }
}

@Configuration
public interface RepositoryConfig {

    @Bean
    AccountRepository accountRepository();
}

@Configuration
public class DefaultRepositoryConfig implements RepositoryConfig {

    @Bean
    public AccountRepository accountRepository() {
        return new JdbcAccountRepository(...);
    }
}

@Configuration
@Import({ServiceConfig.class, DefaultRepositoryConfig.class})  // 导入具体配置！
public class SystemTestConfig {

    @Bean
    public DataSource dataSource() {
        // 返回 DataSource
    }

}

public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);
    TransferService transferService = ctx.getBean(TransferService.class);
    transferService.transfer(100.00, "A123", "C456");
}
----

现在 `ServiceConfig` 相对于具体的 `DefaultRepositoryConfig` 来说是松散耦合的，并且内置的 IDE 工具仍然有用：你可以轻松获取 `RepositoryConfig` 实现的类型层次结构。通过这种方式，导航 `@Configuration` 类及其依赖关系与导航基于接口的代码没有什么不同。
--

TIP: 如果你想影响某些 bean 的启动创建顺序，请考虑将其中一些声明为 `@Lazy`（在首次访问时创建而不是在启动时创建）或声明为 `@DependsOn` 某些其他 bean（确保在当前 bean 之前创建特定的其他 bean，超出了后者的直接依赖关系所暗示的）。


[[beans-java-conditional]]
==== 有条件地包含 `@Configuration` 类或 `@Bean` 方法

根据某些任意的系统状态，有时需要有条件地启用或禁用完整的 `@Configuration` 类甚至单个 `@Bean` 方法。一个常见的例子是使用 `@Profile` 注解，仅在特定配置文件在 Spring `Environment` 中启用时激活 bean（有关详细信息，请参见 <<beans-definition-profiles>>）。

`@Profile` 注解实际上是通过使用一个更灵活的注解实现的，即 {api-spring-framework}/context/annotation/Conditional.html[`@Conditional`]。`@Conditional` 注解指示在注册 `@Bean` 之前应查询的特定 `org.springframework.context.annotation.Condition` 实现。

`Condition` 接口的实现提供了一个 `matches(...)` 方法，该方法返回 `true` 或 `false`。例如，以下列表展示了 `@Profile` 实际使用的 `Condition` 实现：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Override
public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
    // 读取 @Profile 注解的属性
    MultiValueMap<String, Object> attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());
    if (attrs != null) {
        for (Object value : attrs.get("value")) {
            if (context.getEnvironment().acceptsProfiles(((String[]) value))) {
                return true;
            }
        }
        return false;
    }
    return true;
}
----

有关更多详细信息，请参见 {api-spring-framework}/context/annotation/Conditional.html[`@Conditional`] javadoc。

[[beans-java-combining]]
==== 结合使用 Java 和 XML 配置

Spring 的 `@Configuration` 类支持并不旨在完全替代 Spring XML。有些功能，如 Spring XML 命名空间，仍然是配置容器的理想方式。在某些情况下，XML 是方便或必要的，你可以选择：要么使用 `ClassPathXmlApplicationContext` 以 "`XML 为中心`" 的方式实例化容器，要么使用 `AnnotationConfigApplicationContext` 以 "`Java 为中心`" 的方式实例化容器，并根据需要使用 `@ImportResource` 注解导入 XML。

[[beans-java-combining-xml-centric]]
===== 以 XML 为中心使用 `@Configuration` 类

从 XML 引导 Spring 容器并以临时方式包含 `@Configuration` 类可能是更可取的。例如，在使用 Spring XML 的大型现有代码库中，创建 `@Configuration` 类并在现有 XML 文件中根据需要包含它们更为容易。本节稍后将介绍如何在这种 "`XML 为中心`" 的情况下使用 `@Configuration` 类的选项。

.[[beans-java-combining-xml-centric-declare-as-bean]] 将 `@Configuration` 类声明为普通的 Spring `<bean/>` 元素
--
请记住，`@Configuration` 类最终是容器中的 bean 定义。在这一系列示例中，我们创建一个名为 `AppConfig` 的 `@Configuration` 类，并将其作为 `<bean/>` 定义包含在 `system-test-config.xml` 中。因为启用了 `<context:annotation-config/>`，容器能够识别 `@Configuration` 注解，并正确处理在 `AppConfig` 中声明的 `@Bean` 方法。

以下示例展示了一个普通的 Java 配置类：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Configuration
public class AppConfig {

    @Autowired
    private DataSource dataSource;

    @Bean
    public AccountRepository accountRepository() {
        return new JdbcAccountRepository(dataSource);
    }

    @Bean
    public TransferService transferService() {
        return new TransferService(accountRepository());
    }
}
----

以下示例展示了 `system-test-config.xml` 文件的部分内容：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<beans>
    <!-- 启用 @Autowired 和 @Configuration 注解的处理 -->
    <context:annotation-config/>
    <context:property-placeholder location="classpath:/com/acme/jdbc.properties"/>

    <bean class="com.acme.AppConfig"/>

    <bean class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <property name="url" value="${jdbc.url}"/>
        <property name="username" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
    </bean>
</beans>
----

以下示例展示了可能的 `jdbc.properties` 文件：

[literal,subs="verbatim,quotes"]
----
jdbc.url=jdbc:hsqldb:hsql://localhost/xdb
jdbc.username=sa
jdbc.password=
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
public static void main(String[] args) {
    ApplicationContext ctx = new ClassPathXmlApplicationContext("classpath:/com/acme/system-test-config.xml");
    TransferService transferService = ctx.getBean(TransferService.class);
    // ...
}
----

NOTE: 在 `system-test-config.xml` 文件中，`AppConfig` `<bean/>` 没有声明 `id` 元素。虽然这样做是可以接受的，但没有必要，因为没有其他 bean 引用了它，而且不太可能通过名称从容器中显式获取它。同样，`DataSource` bean 仅按类型自动注入，因此不严格要求显式的 bean `id`。
--

.[[beans-java-combining-xml-centric-component-scan]] 使用 `<context:component-scan/>` 来拾取 `@Configuration` 类
--
由于 `@Configuration` 是用 `@Component` 元注解的，因此 `@Configuration` 注解的类会自动成为组件扫描的候选对象。使用前面示例中描述的相同场景，我们可以重新定义 `system-test-config.xml` 以利用组件扫描。注意，在这种情况下，我们不需要显式声明 `<context:annotation-config/>`，因为 `<context:component-scan/>` 启用了相同的功能。

以下示例展示了修改后的 `system-test-config.xml` 文件：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<beans>
    <!-- 拾取并注册 AppConfig 作为 bean 定义 -->
    <context:component-scan base-package="com.acme"/>
    <context:property-placeholder location="classpath:/com/acme/jdbc.properties"/>

    <bean class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <property name="url" value="${jdbc.url}"/>
        <property name="username" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
    </bean>
</beans>
----
--

[[beans-java-combining-java-centric]]
===== 使用 `@ImportResource` 的 `@Configuration` 类为中心的 XML

在 `@Configuration` 类是配置容器的主要机制的应用程序中，仍然可能需要使用至少一些 XML。在这些场景中，你可以使用 `@ImportResource` 并仅定义所需的 XML。这样做实现了配置容器的 "`以 Java 为中心`" 的方法，并将 XML 保持在最低限度。以下示例展示了如何使用 `@ImportResource` 注解来实现 "`以 Java 为中心`" 的配置，该配置根据需要使用 XML：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Configuration
@ImportResource("classpath:/com/acme/properties-config.xml")
public class AppConfig {

    @Value("${jdbc.url}")
    private String url;

    @Value("${jdbc.username}")
    private String username;

    @Value("${jdbc.password}")
    private String password;

    @Bean
    public DataSource dataSource() {
        return new DriverManagerDataSource(url, username, password);
    }
}
----

[source,xml,indent=0,subs="verbatim,quotes"]
----
properties-config.xml
<beans>
    <context:property-placeholder location="classpath:/com/acme/jdbc.properties"/>
</beans>
----

[literal,subs="verbatim,quotes"]
----
jdbc.properties
jdbc.url=jdbc:hsqldb:hsql://localhost/xdb
jdbc.username=sa
jdbc.password=
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);
    TransferService transferService = ctx.getBean(TransferService.class);
    // ...
}
----




[[beans-environment]]
== Environment 抽象

{api-spring-framework}/core/env/Environment.html[`Environment`] 接口是集成在容器中的一个抽象，用于建模应用程序环境的两个关键方面：<<beans-definition-profiles, profiles>> 和 <<beans-property-source-abstraction, properties>>。

profile 是一个命名的逻辑 bean 定义组，仅在给定的 profile 处于激活状态时才会注册到容器中。无论是在 XML 中定义还是使用注解定义的 bean，都可以分配给某个 profile。`Environment` 对象的作用是确定哪些 profile（如果有的话）当前处于激活状态，以及哪些 profile（如果有的话）应该默认激活。

属性在几乎所有应用程序中都扮演着重要角色，属性可以来自多种来源：属性文件、JVM 系统属性、系统环境变量、JNDI、servlet 上下文参数、临时的 `Properties` 对象、`Map` 对象等等。`Environment` 对象的作用是为用户提供一个方便的服务接口，用于配置属性源并从中解析属性。

[[beans-definition-profiles]]
=== Bean 定义 Profile

Bean 定义 profile 为核心容器提供了一种机制，允许在不同的环境中注册不同的 bean。`环境（environment）`这个词对不同用户来说可能意味着不同的东西，这个特性可以帮助处理许多用例，包括：

* 在开发环境中使用内存数据库，而在 QA 或生产环境中通过 JNDI 查找相同的数据源。
* 仅在将应用程序部署到性能环境中时注册监控基础设施。
* 在为客户 A 和客户 B 部署时注册定制的 bean 实现。

考虑到第一个用例，在实际应用中需要 `DataSource`。在测试环境中，配置可能如下所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Bean
public DataSource dataSource() {
    return new EmbeddedDatabaseBuilder()
        .setType(EmbeddedDatabaseType.HSQL)
        .addScript("my-schema.sql")
        .addScript("my-test-data.sql")
        .build();
}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
@Bean
fun dataSource(): DataSource {
    return EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript("my-schema.sql")
            .addScript("my-test-data.sql")
            .build()
}
----

现在，假设应用程序的数据源在生产应用服务器的 JNDI 目录中注册，考虑将此应用程序部署到 QA 或生产环境中。我们的 `dataSource` bean 现在看起来如下：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Bean(destroyMethod="")
public DataSource dataSource() throws Exception {
    Context ctx = new InitialContext();
    return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
@Bean(destroyMethod = "")
fun dataSource(): DataSource {
    val ctx = InitialContext()
    return ctx.lookup("java:comp/env/jdbc/datasource") as DataSource
}
----

问题在于如何根据当前环境在这两个变体之间切换。长期以来，Spring 用户已经想出了多种方法来解决这个问题，通常依赖于系统环境变量和包含 `${placeholder}` 标记的 XML `<import/>` 语句，这些标记根据环境变量的值解析为正确的配置文件路径。Bean 定义 profile 是核心容器提供的一个特性，解决了这个问题。

如果我们将前面示例中环境特定 bean 定义的用例进行概括，我们最终需要在某些上下文中注册某些 bean 定义，而在其他上下文中不注册。你可以说，你想在情况 A 中注册某些 bean 定义的 profile，而在情况 B 中注册不同的 profile。我们从更新配置开始，以反映这一需求。

[[beans-definition-profiles-java]]
==== 使用 `@Profile`

{api-spring-framework}/context/annotation/Profile.html[`@Profile`] 注解允许你指明某个组件在一个或多个指定的 profile 处于激活状态时才符合注册条件。使用我们之前的示例，我们可以将 `dataSource` 配置重写如下：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Configuration
@Profile("development")
public class StandaloneDataConfig {

    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript("classpath:com/bank/config/sql/schema.sql")
            .addScript("classpath:com/bank/config/sql/test-data.sql")
            .build();
    }
}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
@Configuration
@Profile("development")
class StandaloneDataConfig {

    @Bean
    fun dataSource(): DataSource {
        return EmbeddedDatabaseBuilder()
                .setType(EmbeddedDatabaseType.HSQL)
                .addScript("classpath:com/bank/config/sql/schema.sql")
                .addScript("classpath:com/bank/config/sql/test-data.sql")
                .build()
    }
}
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Configuration
@Profile("production")
public class JndiDataConfig {

    @Bean(destroyMethod="")
    public DataSource dataSource() throws Exception {
        Context ctx = new InitialContext();
        return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
    }
}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
@Configuration
@Profile("production")
class JndiDataConfig {

    @Bean(destroyMethod = "")
    fun dataSource(): DataSource {
        val ctx = InitialContext()
        return ctx.lookup("java:comp/env/jdbc/datasource") as DataSource
    }
}
----

NOTE: 正如前面提到的，使用 `@Bean` 方法时，你通常选择使用编程方式进行 JNDI 查找，使用 Spring 的 `JndiTemplate` / `JndiLocatorDelegate` 辅助工具，或使用前面展示的直接 JNDI `InitialContext` 用法，但不使用 `JndiObjectFactoryBean` 变体，因为那样会强制你将返回类型声明为 `FactoryBean` 类型。

profile 字符串可以包含一个简单的 profile 名称（例如 `production`）或一个 profile 表达式。profile 表达式允许表达更复杂的 profile 逻辑（例如 `production & us-east`）。profile 表达式支持以下操作符：

* `!`：逻辑 "`非`"（not） profile
* `&`：逻辑 "`与`"（and） profile
* `|`：逻辑 "`或`"（or） profile

NOTE: 不能在不使用括号的情况下混合使用 `&` 和 `|` 操作符。例如，`production & us-east | eu-central` 不是有效表达式。必须表示为 `production & (us-east | eu-central)`。

你可以将 `@Profile` 用作 <<beans-meta-annotations, meta-annotation>> 来创建自定义组合注解。以下示例定义了一个自定义 `@Production` 注解，可以作为 `@Profile("production")` 的直接替代：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Profile("production")
public @interface Production {
}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
@Target(AnnotationTarget.TYPE)
@Retention(AnnotationRetention.RUNTIME)
@Profile("production")
annotation class Production
----

TIP: 如果一个 `@Configuration` 类标记了 `@Profile`，则与该类关联的所有 `@Bean` 方法和 `@Import` 注解都将被忽略，除非激活了一个或多个指定的 profile。如果一个 `@Component` 或 `@Configuration` 类标记了 `@Profile({"p1", "p2"})`，除非激活了 profile 'p1' 或 'p2'，否则不会注册或处理该类。如果给定的 profile 以 NOT 操作符（`!`）作为前缀，只有当该 profile 未激活时才会注册带有注解的元素。例如，给定 `@Profile({"p1", "!p2"})`，如果 profile 'p1' 激活或 profile 'p2' 未激活，则会进行注册。

`@Profile` 也可以在方法级别声明，以包含配置类中的某个特定 bean（例如，某个 bean 的替代变体），如下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Configuration
public class AppConfig {

    @Bean("dataSource")
    @Profile("development") // <1>
    public DataSource standaloneDataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript("classpath:com/bank/config/sql/schema.sql")
            .addScript("classpath:com/bank/config/sql/test-data.sql")
            .build();
    }

    @Bean("dataSource")
    @Profile("production") // <2>
    public DataSource jndiDataSource() throws Exception {
        Context ctx = new InitialContext();
        return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
    }
}
----
<1> `standaloneDataSource` 方法仅在 `development` profile 中可用。
<2> `jndiDataSource` 方法仅在 `production` profile 中可用。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
@Configuration
class AppConfig {

    @Bean("dataSource")
    @Profile("development") // <1>
    fun standaloneDataSource(): DataSource {
        return EmbeddedDatabaseBuilder()
                .setType(EmbeddedDatabaseType.HSQL)
                .addScript("classpath:com/bank/config/sql/schema.sql")
                .addScript("classpath:com/bank/config/sql/test-data.sql")
                .build()
    }

    @Bean("dataSource")
    @Profile("production") // <2>
    fun jndiDataSource() =
        InitialContext().lookup("java:comp/env/jdbc/datasource") as DataSource
}
----
<1> `standaloneDataSource` 方法仅在 `development` profile 中可用。
<2> `jndiDataSource` 方法仅在 `production` profile 中可用。

[NOTE]
====
对于 `@Profile` 在 `@Bean` 方法上的使用，可能存在特殊情况：对于具有相同 Java 方法名称的重载 `@Bean` 方法（类似于构造函数重载），需要在所有重载方法上保持一致声明 `@Profile` 条件。如果条件不一致，则只有第一个重载方法上的条件才有效。因此，`@Profile` 不能用于选择特定参数签名的重载方法。对同一个 bean 的所有工厂方法的解析是在创建时遵循 Spring 的构造函数解析算法。

如果你想使用不同的 profile 条件定义替代的 bean，请使用不同的 Java 方法名称，并通过 `@Bean` 的 name 属性指向同一个 bean 名称，如前面的示例所示。如果所有变体的参数签名都是相同的（例如，所有变体都有无参数工厂方法），这是在有效 Java 类中表示此类安排的唯一方法（因为只能有一个特定名称和参数签名的方法）。
====

[[beans-definition-profiles-xml]]
==== XML Bean 定义 Profile

XML 对应项是 `<beans>` 元素的 `profile` 属性。我们之前的示例配置可以在两个 XML 文件中重写，如下所示：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<beans profile="development"
    xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:jdbc="http://www.springframework.org/schema/jdbc"
    xsi:schemaLocation="...">

    <jdbc:embedded-database id="dataSource">
        <jdbc:script location="classpath:com/bank/config/sql/schema.sql"/>
        <jdbc:script location="classpath:com/bank/config/sql/test-data.sql"/>
    </jdbc:embedded-database>
</beans>
----

[source,xml,indent=0,subs="verbatim,quotes"]
----
<beans profile="production"
    xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:jee="http://www.springframework.org/schema/jee"
    xsi:schemaLocation="...">

    <jee:jndi-lookup id="dataSource" jndi-name="java:comp/env/jdbc/datasource"/>
</beans>
----

还可以避免这种拆分，并在同一个文件中嵌套 `<beans/>` 元素，如下示例所示：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:jdbc="http://www.springframework.org/schema/jdbc"
    xmlns:jee="http://www.springframework.org/schema/jee"
    xsi:schemaLocation="...">

    <!-- 其他 bean 定义 -->

    <beans profile="development">
        <jdbc:embedded-database id="dataSource">
            <jdbc:script location="classpath:com/bank/config/sql/schema.sql"/>
            <jdbc:script location="classpath:com/bank/config/sql/test-data.sql"/>
        </jdbc:embedded-database>
    </beans>

    <beans profile="production">
        <jee:jndi-lookup id="dataSource" jndi-name="java:comp/env/jdbc/datasource"/>
    </beans>
</beans>
----

`spring-bean.xsd` 已经被约束，只允许在文件中的最后一个元素是这样的元素。这有助于提供灵活性，而不会导致 XML 文件的混乱。

[NOTE]
=====
XML 对应项不支持前面描述的 profile 表达式。然而，可以使用 `!` 操作符来否定一个 profile。还可以通过嵌套 profile 实现逻辑 "`与`" 操作，如下示例所示：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:jdbc="http://www.springframework.org/schema/jdbc"
    xmlns:jee="http://www.springframework.org/schema/jee"
    xsi:schemaLocation="...">

    <!-- 其他 bean 定义 -->

    <beans profile="production">
        <beans profile="us-east">
            <jee:jndi-lookup id="dataSource" jndi-name="java:comp/env/jdbc/datasource"/>
        </beans>
    </beans>
</beans>
----

在上例中，如果 `production` 和 `us-east` profile 都处于激活状态，则会公开 `dataSource` bean。
=====


[[beans-definition-profiles-enable]]
==== 激活 Profile

现在我们已经更新了配置，但仍需要指示 Spring 哪个 profile 是激活的。如果我们现在启动示例应用程序，将会看到 `NoSuchBeanDefinitionException` 异常，因为容器找不到名为 `dataSource` 的 Spring bean。

激活 profile 有几种方式，但最直接的方法是通过 `Environment` API 以编程方式激活，该 API 可以通过 `ApplicationContext` 获得。以下示例展示了如何操作：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
ctx.getEnvironment().setActiveProfiles("development");
ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);
ctx.refresh();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
val ctx = AnnotationConfigApplicationContext().apply {
    environment.setActiveProfiles("development")
    register(SomeConfig::class.java, StandaloneDataConfig::class.java, JndiDataConfig::class.java)
    refresh()
}
----

此外，你还可以通过 `spring.profiles.active` 属性声明性地激活 profile，该属性可以通过系统环境变量、JVM 系统属性、`web.xml` 中的 servlet 上下文参数，甚至是 JNDI 中的条目来指定（参见 <<beans-property-source-abstraction>>）。在集成测试中，活跃的 profile 可以通过 `spring-test` 模块中的 `@ActiveProfiles` 注解来声明（参见 <<testing.adoc#testcontext-ctx-management-env-profiles, 使用环境 profile 的上下文配置>>）。

注意，profile 不是一种 "`非此即彼`" 的选择。你可以一次激活多个 profile。在编程方式下，你可以将多个 profile 名称提供给 `setActiveProfiles()` 方法，该方法接受 `String...` 可变参数。以下示例激活了多个 profile：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
ctx.getEnvironment().setActiveProfiles("profile1", "profile2");
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
ctx.getEnvironment().setActiveProfiles("profile1", "profile2")
----

在声明方式下，`spring.profiles.active` 可以接受以逗号分隔的 profile 名称列表，如下示例所示：

[literal,subs="verbatim,quotes"]
----
-Dspring.profiles.active="profile1,profile2"
----

[[beans-definition-profiles-default]]
==== 默认 Profile

默认 profile 代表默认启用的 profile。考虑以下示例：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Configuration
@Profile("default")
public class DefaultDataConfig {

    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript("classpath:com/bank/config/sql/schema.sql")
            .build();
    }
}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
@Configuration
@Profile("default")
class DefaultDataConfig {

    @Bean
    fun dataSource(): DataSource {
        return EmbeddedDatabaseBuilder()
                .setType(EmbeddedDatabaseType.HSQL)
                .addScript("classpath:com/bank/config/sql/schema.sql")
                .build()
    }
}
----

如果没有任何 profile 处于活跃状态，则会创建 `dataSource`。你可以将此视为为一个或多个 bean 提供默认定义的方法。如果任何 profile 被启用，默认 profile 将不会生效。

你可以通过 `Environment` 的 `setDefaultProfiles()` 方法更改默认 profile 的名称，或通过 `spring.profiles.default` 属性以声明方式进行更改。

[[beans-property-source-abstraction]]
=== `PropertySource` 抽象

Spring 的 `Environment` 抽象提供了在可配置的属性源层次结构中进行搜索操作的功能。考虑以下代码片段：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
ApplicationContext ctx = new GenericApplicationContext();
Environment env = ctx.getEnvironment();
boolean containsMyProperty = env.containsProperty("my-property");
System.out.println("Does my environment contain the 'my-property' property? " + containsMyProperty);
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
val ctx = GenericApplicationContext()
val env = ctx.environment
val containsMyProperty = env.containsProperty("my-property")
println("Does my environment contain the 'my-property' property? $containsMyProperty")
----

在上面的代码片段中，我们看到了一种高级方法来询问 Spring 当前环境中是否定义了 `my-property` 属性。为回答这个问题，`Environment` 对象会在一组 {api-spring-framework}/core/env/PropertySource.html[`PropertySource`] 对象上进行搜索。`PropertySource` 是对任何键值对来源的简单抽象，而 Spring 的 {api-spring-framework}/core/env/StandardEnvironment.html[`StandardEnvironment`] 配置了两个 PropertySource 对象——一个代表 JVM 系统属性集（`System.getProperties()`），另一个代表系统环境变量集（`System.getenv()`）。

NOTE: 这些默认的属性源适用于 `StandardEnvironment`，用于独立应用程序。{api-spring-framework}/web/context/support/StandardServletEnvironment.html[`StandardServletEnvironment`] 中填充了包括 servlet 配置和 servlet 上下文参数在内的其他默认属性源。它还可以选择性地启用 {api-spring-framework}/jndi/JndiPropertySource.html[`JndiPropertySource`]。有关详细信息，请参阅 javadoc。

具体来说，当你使用 `StandardEnvironment` 时，如果运行时存在 `my-property` 系统属性或 `my-property` 环境变量，则对 `env.containsProperty("my-property")` 的调用返回 true。

[TIP]
====
搜索是分层次进行的。默认情况下，系统属性优先于环境变量。因此，如果在调用 `env.getProperty("my-property")` 时 `my-property` 属性在两个地方都设置了，系统属性值将 "`获胜`" 并被返回。请注意，属性值不会被合并，而是完全被前面的条目覆盖。

对于常见的 `StandardServletEnvironment`，完整的层次结构如下，最高优先级的条目位于顶部：

. ServletConfig 参数（如果适用——例如，在 `DispatcherServlet` 上下文中）
. ServletContext 参数（web.xml 中的 context-param 条目）
. JNDI 环境变量（`java:comp/env/` 条目）
. JVM 系统属性（`-D` 命令行参数）
. JVM 系统环境（操作系统环境变量）
====

最重要的是，整个机制是可配置的。也许你有一个自定义的属性来源，想要将其集成到此搜索中。要做到这一点，实施并实例化你自己的 `PropertySource`，并将其添加到当前 `Environment` 的 `PropertySources` 集合中。以下示例展示了如何操作：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
ConfigurableApplicationContext ctx = new GenericApplicationContext();
MutablePropertySources sources = ctx.getEnvironment().getPropertySources();
sources.addFirst(new MyPropertySource());
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
val ctx = GenericApplicationContext()
val sources = ctx.environment.propertySources
sources.addFirst(MyPropertySource())
----

在上面的代码中，`MyPropertySource` 以最高优先级添加到搜索中。如果它包含 `my-property` 属性，则会检测并返回该属性，而不是其他任何 `PropertySource` 中的 `my-property` 属性。{api-spring-framework}/core/env/MutablePropertySources.html[`MutablePropertySources`] API 提供了许多方法，可以精确操作属性源集合。

[[beans-using-propertysource]]
=== 使用 `@PropertySource`

{api-spring-framework}/context/annotation/PropertySource.html[`@PropertySource`] 注解提供了一种方便的声明机制，将 `PropertySource` 添加到 Spring 的 `Environment` 中。

假设有一个名为 `app.properties` 的文件，包含键值对 `testbean.name=myTestBean`，以下 `@Configuration` 类使用 `@PropertySource`，这样调用 `testBean.getName()` 返回 `myTestBean`：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Configuration
@PropertySource("classpath:/com/myco/app.properties")
public class AppConfig {

    @Autowired
    Environment env;

    @Bean
    public TestBean testBean() {
        TestBean testBean = new TestBean();
        testBean.setName(env.getProperty("testbean.name"));
        return testBean;
    }
}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
@Configuration
@PropertySource("classpath:/com/myco/app.properties")
class AppConfig {

    @Autowired
    private lateinit var env: Environment

    @Bean
    fun testBean() = TestBean().apply {
        name = env.getProperty("testbean.name")!!
    }
}
----

任何 `${...}` 占位符出现在 `@PropertySource` 资源位置中时，将根据已经在环境中注册的属性源集进行解析，如下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@Configuration
@PropertySource("classpath:/com/${my.placeholder:default/path}/app.properties")
public class AppConfig {

    @Autowired
    Environment env;

    @Bean
    public TestBean testBean() {
        TestBean testBean = new TestBean();
        testBean.setName(env.getProperty("testbean.name"));
        return testBean;
    }
}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
@Configuration
@PropertySource("classpath:/com/\${my.placeholder:default/path}/app.properties")
class AppConfig {

    @Autowired
    private lateinit var env: Environment

    @Bean
    fun testBean() = TestBean().apply {
        name = env.getProperty("testbean.name")!!
    }
}
----

假设 `my.placeholder` 存在于已经注册的某个属性源中（例如系统属性或环境变量），则占位符将解析为相应的值。如果没有，则使用 `default/path` 作为默认值。如果没有指定默认值且属性无法解析，则抛出 `IllegalArgumentException`。

NOTE: `@PropertySource` 注解是可重复的，符合 Java 8 的约定。然而，所有这样的 `@PropertySource` 注解需要在同一级别声明，要么直接在配置类上声明，要么作为同一个自定义注解内的元注解。混合直接注解和元注解不推荐，因为直接注解实际上会覆盖元注解。

[[beans-placeholder-resolution-in-statements]]
=== 语句中的占位符解析

历史上，元素中占位符的值只能根据 JVM 系统属性或环境变量进行解析。现在情况不再是这样。由于 `Environment` 抽象已经集成到整个容器中，可以轻松地通过它进行解析过程的配置。这意味着你可以以任何喜欢的方式配置解析过程。你可以更改搜索系统属性和环境变量的优先级，或完全删除它们。你还可以根据需要添加自己的属性源。

具体来说，只要 `Environment` 中定义了 `customer` 属性，以下语句在任何地方都可以正常工作：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<beans>
    <import resource="com/bank/service/${customer}-config.xml"/>
</beans>
----



[[context-functionality-events]]
=== 标准事件与自定义事件

`ApplicationContext` 中的事件处理通过 `ApplicationEvent` 类和 `ApplicationListener` 接口提供。如果一个 bean 实现了 `ApplicationListener` 接口并被部署到上下文中，每当一个 `ApplicationEvent` 发布到 `ApplicationContext` 时，该 bean 都会收到通知。本质上，这是标准的观察者设计模式。

TIP: 从 Spring 4.2 开始，事件基础设施得到了显著改进，提供了一个 <<context-functionality-events-annotation, 基于注解的模型>>，并且可以发布任意的事件对象（即不一定要继承自 `ApplicationEvent` 的对象）。当这样的对象被发布时，我们会为你包装成一个事件。

以下表格描述了 Spring 提供的标准事件：

[[beans-ctx-events-tbl]]
.内置事件
[cols="30%,70%"]
|===
| 事件| 说明

| `ContextRefreshedEvent`
| 当 `ApplicationContext` 被初始化或刷新时（例如，通过在 `ConfigurableApplicationContext` 接口上使用 `refresh()` 方法），该事件会发布。在这里，“`初始化`”意味着所有 bean 都已加载，后处理器 bean 被检测并激活，单例 bean 已被预实例化，并且 `ApplicationContext` 对象已准备好使用。只要上下文未关闭，可以多次触发刷新，前提是所选的 `ApplicationContext` 实际上支持这种“`热`”刷新。例如，`XmlWebApplicationContext` 支持热刷新，但 `GenericApplicationContext` 不支持。

| `ContextStartedEvent`
| 当 `ApplicationContext` 通过 `ConfigurableApplicationContext` 接口上的 `start()` 方法启动时发布。在这里，“`启动`”意味着所有 `Lifecycle` bean 收到显式启动信号。通常，该信号用于在显式停止后重新启动 bean，但它也可以用于启动那些尚未配置为自动启动的组件（例如，那些尚未在初始化时启动的组件）。

| `ContextStoppedEvent`
| 当 `ApplicationContext` 通过 `ConfigurableApplicationContext` 接口上的 `stop()` 方法停止时发布。在这里，“`停止`”意味着所有 `Lifecycle` bean 收到显式停止信号。已停止的上下文可以通过 `start()` 调用重新启动。

| `ContextClosedEvent`
| 当 `ApplicationContext` 通过 `ConfigurableApplicationContext` 接口上的 `close()` 方法或通过 JVM 关闭钩子关闭时发布。在这里，“关闭”意味着所有单例 bean 都将被销毁。一旦上下文关闭，它将达到生命周期的终点，无法刷新或重新启动。

| `RequestHandledEvent`
| 一个特定于 Web 的事件，通知所有 bean 一个 HTTP 请求已被处理。该事件在请求完成后发布。此事件仅适用于使用 Spring 的 `DispatcherServlet` 的 Web 应用程序。

| `ServletRequestHandledEvent`
| `RequestHandledEvent` 的子类，增加了 Servlet 特定的上下文信息。

|===

你还可以创建并发布自己的自定义事件。以下示例展示了一个简单的类，扩展了 Spring 的 `ApplicationEvent` 基类：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
public class BlockedListEvent extends ApplicationEvent {

    private final String address;
    private final String content;

    public BlockedListEvent(Object source, String address, String content) {
        super(source);
        this.address = address;
        this.content = content;
    }

    // 访问器和其他方法...
}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
class BlockedListEvent(source: Any,
                    val address: String,
                    val content: String) : ApplicationEvent(source)
----

要发布自定义的 `ApplicationEvent`，调用 `ApplicationEventPublisher` 上的 `publishEvent()` 方法。通常，通过创建一个实现 `ApplicationEventPublisherAware` 的类并将其注册为 Spring bean 来完成这一操作。以下示例展示了这样一个类：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
public class EmailService implements ApplicationEventPublisherAware {

    private List<String> blockedList;
    private ApplicationEventPublisher publisher;

    public void setBlockedList(List<String> blockedList) {
        this.blockedList = blockedList;
    }

    public void setApplicationEventPublisher(ApplicationEventPublisher publisher) {
        this.publisher = publisher;
    }

    public void sendEmail(String address, String content) {
        if (blockedList.contains(address)) {
            publisher.publishEvent(new BlockedListEvent(this, address, content));
            return;
        }
        // 发送电子邮件...
    }
}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
class EmailService : ApplicationEventPublisherAware {

    private lateinit var blockedList: List<String>
    private lateinit var publisher: ApplicationEventPublisher

    fun setBlockedList(blockedList: List<String>) {
        this.blockedList = blockedList
    }

    override fun setApplicationEventPublisher(publisher: ApplicationEventPublisher) {
        this.publisher = publisher
    }

    fun sendEmail(address: String, content: String) {
        if (blockedList!!.contains(address)) {
            publisher!!.publishEvent(BlockedListEvent(this, address, content))
            return
        }
        // 发送电子邮件...
    }
}
----

在配置时，Spring 容器检测到 `EmailService` 实现了 `ApplicationEventPublisherAware`，并自动调用 `setApplicationEventPublisher()`。实际上，传递的参数是 Spring 容器本身。你通过其 `ApplicationEventPublisher` 接口与应用上下文进行交互。

要接收自定义的 `ApplicationEvent`，你可以创建一个实现 `ApplicationListener` 的类，并将其注册为 Spring bean。以下示例展示了这样一个类：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
public class BlockedListNotifier implements ApplicationListener<BlockedListEvent> {

    private String notificationAddress;

    public void setNotificationAddress(String notificationAddress) {
        this.notificationAddress = notificationAddress;
    }

    public void onApplicationEvent(BlockedListEvent event) {
        // 通过 notificationAddress 通知相关方...
    }
}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
class BlockedListNotifier : ApplicationListener<BlockedListEvent> {

    lateinit var notificationAddres: String

    override fun onApplicationEvent(event: BlockedListEvent) {
        // 通过 notificationAddress 通知相关方...
    }
}
----

请注意，`ApplicationListener` 是用你的自定义事件类型（在上面的示例中为 `BlockedListEvent`）进行泛型参数化的。这意味着 `onApplicationEvent()` 方法可以保持类型安全，无需进行向下转型。你可以注册任意数量的事件监听器，但请注意，默认情况下，事件监听器同步接收事件。这意味着 `publishEvent()` 方法会阻塞，直到所有监听器完成事件处理。这种同步和单线程方法的一个优点是，当监听器接收到事件时，如果有事务上下文可用，它将在发布者的事务上下文中操作。如果需要其他事件发布策略，请参阅 Spring 的 {api-spring-framework}/context/event/ApplicationEventMulticaster.html[`ApplicationEventMulticaster`] 接口和 {api-spring-framework}/context/event/SimpleApplicationEventMulticaster.html[`SimpleApplicationEventMulticaster`] 实现的 javadoc 以获取配置选项。

以下示例展示了用于注册和配置上述每个类的 bean 定义：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<bean id="emailService" class="example.EmailService">
    <property name="blockedList">
        <list>
            <value>known.spammer@example.org</value>
            <value>known.hacker@example.org</value>
            <value>john.doe@example.org</value>
        </list>
    </property>
</bean>

<bean id="blockedListNotifier" class="example.BlockedListNotifier">
    <property name="notificationAddress" value="blockedlist@example.org"/>
</bean>
----

把这些放在一起，当调用 `emailService` bean 的 `sendEmail()` 方法时，如果有任何电子邮件应被阻止，将发布一个 `BlockedListEvent` 类型的自定义事件。`blockedListNotifier` bean 被注册为 `ApplicationListener`，并接收到 `BlockedListEvent`，此时它可以通知相关方。

NOTE: Spring 的事件机制旨在为同一应用上下文中的 Spring bean 提供简单的通信。然而，对于更复杂的企业集成需求，独立维护的 https://projects.spring.io/spring-integration/[Spring Integration] 项目提供了全面支持，帮助你构建轻量级的、基于 https://www.enterpriseintegrationpatterns.com[模式导向] 的事件驱动架构，并建立在广为人知的 Spring 编程模型之上。

[[context-functionality-events-annotation]]
==== 基于注解的事件监听器

你可以使用 `@EventListener` 注解在受管 bean 的任意方法上注册事件监听器。`BlockedListNotifier` 可以重写如下：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
public class BlockedListNotifier {

    private String notificationAddress;

    public void setNotificationAddress(String notificationAddress) {
        this.notificationAddress = notificationAddress;
    }

    @EventListener
    public void processBlockedListEvent(BlockedListEvent event) {
        // 通过 notificationAddress 通知相关方...
    }
}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
class BlockedListNotifier {

    lateinit var notificationAddress: String

    @EventListener
    fun processBlockedListEvent(event: BlockedListEvent) {
        // 通过 notificationAddress 通知相关方...
    }
}
----

方法签名再次声明了它监听的事件类型，但这次是以灵活的名称，而不是实现特定的监听器接口。只要实际的事件类型在其实现层次结构中解析了你的泛型参数，也可以通过泛型缩小事件类型的范围。

如果你的方法应该监听多个事件，或者你希望定义一个没有参数的方法，也可以在注解本身上指定事件类型。如下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@EventListener({ContextStartedEvent.class, ContextRefreshedEvent.class})
public void handleContextStart() {
    // ...
}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
@EventListener(ContextStartedEvent::class, ContextRefreshedEvent::class)
fun handleContextStart() {
    // ...
}
----

还可以通过使用注解的 `condition` 属性添加额外的运行时过滤条件，该条件定义了一个 <<expressions, `SpEL` 表达式>>，该表达式应匹配以实际为特定事件调用该方法。

以下示例展示了如何将我们的通知器重写为仅在事件的 `content` 属性等于 `my-event` 时被调用：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@EventListener(condition = "#blEvent.content == 'my-event'")
public void processBlockedListEvent(BlockedListEvent blEvent) {
    // 通过 notificationAddress 通知相关方...
}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
@EventListener(condition = "#blEvent.content == 'my-event'")
fun processBlockedListEvent(blEvent: BlockedListEvent) {
    // 通过 notificationAddress 通知相关方...
}
----

每个 `SpEL` 表达式都针对专用上下文进行评估。以下表格列出了上下文中可用的项目，你可以使用它们进行条件事件处理：

[[context-functionality-events-annotation-tbl]]
.事件 SpEL 可用元数据
|===
| 名称| 位置| 描述| 示例

| Event
| 根对象
| 实际的 `ApplicationEvent`。
| `#root.event` 或 `event`

| 参数数组
| 根对象
| 用于调用方法的参数（作为对象数组）。
| `#root.args` 或 `args`；`args[0]` 访问第一个参数，依此类推。

| __参数名称__
| 评估上下文
| 方法参数的名称。如果由于某种原因名称不可用（例如，由于编译的字节码中没有调试信息），也可以使用 `#a<#arg>` 语法访问单个参数，其中 `<#arg>` 代表参数索引（从 0 开始）。
| `#blEvent` 或 `#a0`（你也可以使用 `#p0` 或 `#p<#arg>` 参数表示法作为别名）
|===

请注意，`#root.event` 允许你访问底层事件，即使你的方法签名实际上引用了一个已发布的任意对象。

如果需要在处理另一个事件的结果时发布事件，可以将方法签名更改为返回应发布的事件，如下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@EventListener
public ListUpdateEvent handleBlockedListEvent(BlockedListEvent event) {
    // 通过 notificationAddress 通知相关方，并
    // 然后发布一个 ListUpdateEvent...
}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
@EventListener
fun handleBlockedListEvent(event: BlockedListEvent): ListUpdateEvent {
    // 通过 notificationAddress 通知相关方，并
    // 然后发布一个 ListUpdateEvent...
}
----

NOTE: 此功能不支持 <<context-functionality-events-async, 异步监听器>>。

`handleBlockedListEvent()` 方法为它处理的每个 `BlockedListEvent` 发布一个新的 `ListUpdateEvent`。如果需要发布多个事件，可以返回 `Collection` 或事件数组。


[[context-functionality-events-async]]
==== 异步监听器

如果你希望某个特定的监听器异步处理事件，可以重用 <<integration.adoc#scheduling-annotation-support-async, 常规的 `@Async` 支持>>。以下示例展示了如何实现：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@EventListener
@Async
public void processBlockedListEvent(BlockedListEvent event) {
    // BlockedListEvent 在单独的线程中处理
}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
@EventListener
@Async
fun processBlockedListEvent(event: BlockedListEvent) {
    // BlockedListEvent 在单独的线程中处理
}
----

在使用异步事件时，请注意以下限制：

* 如果异步事件监听器抛出 `Exception`，它不会传播给调用者。详情请参阅 {api-spring-framework}/aop/interceptor/AsyncUncaughtExceptionHandler.html[`AsyncUncaughtExceptionHandler`]。
* 异步事件监听器方法不能通过返回值发布后续事件。如果需要在处理过程中发布另一个事件，请注入 {api-spring-framework}/context/ApplicationEventPublisher.html[`ApplicationEventPublisher`] 以手动发布事件。


[[context-functionality-events-order]]
==== 监听器的顺序

如果你需要一个监听器在另一个监听器之前被调用，可以在方法声明中添加 `@Order` 注解，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@EventListener
@Order(42)
public void processBlockedListEvent(BlockedListEvent event) {
    // 通过 notificationAddress 通知相关方...
}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
@EventListener
@Order(42)
fun processBlockedListEvent(event: BlockedListEvent) {
    // 通过 notificationAddress 通知相关方...
}
----


[[context-functionality-events-generics]]
==== 泛型事件

你还可以使用泛型进一步定义事件的结构。例如，可以使用 `EntityCreatedEvent<T>`，其中 `T` 是实际创建的实体的类型。例如，你可以创建以下监听器定义来仅接收 `Person` 的 `EntityCreatedEvent`：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
@EventListener
public void onPersonCreated(EntityCreatedEvent<Person> event) {
    // ...
}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
@EventListener
fun onPersonCreated(event: EntityCreatedEvent<Person>) {
    // ...
}
----

由于类型擦除，这仅在事件触发时解析了事件监听器过滤的泛型参数时才有效（即类似 `class PersonCreatedEvent extends EntityCreatedEvent<Person> { ... }` 的情况）。

在某些情况下，如果所有事件都遵循相同的结构（如前面示例中的事件应该那样），这可能会变得相当繁琐。在这种情况下，你可以实现 `ResolvableTypeProvider` 以引导框架超越运行时环境提供的内容。以下事件展示了如何实现：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
public class EntityCreatedEvent<T> extends ApplicationEvent implements ResolvableTypeProvider {

    public EntityCreatedEvent(T entity) {
        super(entity);
    }

    @Override
    public ResolvableType getResolvableType() {
        return ResolvableType.forClassWithGenerics(getClass(), ResolvableType.forInstance(getSource()));
    }
}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
class EntityCreatedEvent<T>(entity: T) : ApplicationEvent(entity), ResolvableTypeProvider {

    override fun getResolvableType(): ResolvableType? {
        return ResolvableType.forClassWithGenerics(javaClass, ResolvableType.forInstance(getSource()))
    }
}
----

TIP: 这不仅适用于 `ApplicationEvent`，还适用于你作为事件发送的任意对象。



[[context-functionality-resources]]
=== 方便访问底层资源

为了最佳地使用和理解应用上下文，你应该熟悉 Spring 的 `Resource` 抽象，如 <<resources>> 所述。

应用上下文是一个 `ResourceLoader`，可用于加载 `Resource` 对象。`Resource` 本质上是 JDK `java.net.URL` 类的一个更强大的版本。实际上，`Resource` 的实现封装了 `java.net.URL` 实例（在适当情况下）。`Resource` 可以透明地从几乎任何位置获取底层资源，包括从类路径、文件系统位置、任何标准 URL 描述的位置等。如果资源位置字符串是一个没有任何特殊前缀的简单路径，这些资源来自何处是特定的，并且取决于实际的应用上下文类型。

可以将部署到应用上下文中的 bean 配置为实现特殊的回调接口 `ResourceLoaderAware`，以便在初始化时自动回调，并将应用上下文本身作为 `ResourceLoader` 传入。你还可以公开类型为 `Resource` 的属性，用于访问静态资源。它们像其他属性一样被注入。可以将这些 `Resource` 属性指定为简单的 `String` 路径，并在 bean 部署时依赖从这些文本字符串到实际 `Resource` 对象的自动转换。

传递给 `ApplicationContext` 构造函数的位置路径实际上是资源字符串，在简单形式下，根据具体的上下文实现，进行适当处理。例如，`ClassPathXmlApplicationContext` 将一个简单的位置路径视为类路径位置。你还可以使用具有特殊前缀的位置路径（资源字符串）强制从类路径或 URL 加载定义，无论实际的上下文类型如何。



[[context-functionality-startup]]
=== 应用启动跟踪

`ApplicationContext` 管理 Spring 应用的生命周期，并提供了一个围绕组件的丰富编程模型。因此，复杂的应用可以有同样复杂的组件图和启动阶段。

通过特定的指标跟踪应用启动步骤，可以帮助理解启动阶段的时间开销，还可以更好地理解整个上下文生命周期。

`AbstractApplicationContext`（及其子类）使用 `ApplicationStartup` 进行监控，收集关于各种启动阶段的 `StartupStep` 数据：

* 应用上下文生命周期（基础包扫描、配置类管理）
* bean 生命周期（实例化、智能初始化、后处理）
* 应用事件处理

以下是 `AnnotationConfigApplicationContext` 中的一个示例：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
    // 创建一个启动步骤并开始记录
    StartupStep scanPackages = this.getApplicationStartup().start("spring.context.base-packages.scan");
    // 向当前步骤添加标签信息
    scanPackages.tag("packages", () -> Arrays.toString(basePackages));
    // 执行我们正在监控的实际阶段
    this.scanner.scan(basePackages);
    // 结束当前步骤
    scanPackages.end();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
    // 创建一个启动步骤并开始记录
    val scanPackages = this.getApplicationStartup().start("spring.context.base-packages.scan")
    // 向当前步骤添加标签信息
    scanPackages.tag("packages", () -> Arrays.toString(basePackages))
    // 执行我们正在监控的实际阶段
    this.scanner.scan(basePackages)
    // 结束当前步骤
    scanPackages.end()
----

应用上下文已经使用多个步骤进行了监控。
一旦记录，这些启动步骤可以使用特定工具进行收集、显示和分析。
有关现有启动步骤的完整列表，请查看 <<application-startup-steps, 专门的附录部分>>。

默认的 `ApplicationStartup` 实现是一个无操作变体，开销极小。
这意味着默认情况下不会在应用启动期间收集任何指标。
Spring 框架附带了一个实现，用于通过 Java Flight Recorder 跟踪启动步骤：`FlightRecorderApplicationStartup`。要使用此变体，你必须在创建 `ApplicationContext` 后尽快配置其实例。

开发人员还可以使用 `ApplicationStartup` 基础设施，如果他们提供自己的 `AbstractApplicationContext` 子类，或者如果他们希望收集更精确的数据。

WARNING: `ApplicationStartup` 仅用于应用启动期间和核心容器中；这绝不是 Java 分析器或类似于 https://micrometer.io[Micrometer] 的度量库的替代品。

要开始收集自定义 `StartupStep`，组件可以直接从应用上下文中获取 `ApplicationStartup` 实例，使其组件实现 `ApplicationStartupAware`，或在任何注入点上请求 `ApplicationStartup` 类型。

NOTE: 开发人员在创建自定义启动步骤时不应使用 `"spring.*"` 命名空间。此命名空间保留供 Spring 内部使用，可能会发生变化。

[[context-create]]
=== 为 Web 应用便捷创建 ApplicationContext 实例

你可以使用 `ContextLoader` 等方式声明式地创建 `ApplicationContext` 实例。当然，你也可以通过使用某个 `ApplicationContext` 实现类以编程方式创建 `ApplicationContext` 实例。

你可以通过使用 `ContextLoaderListener` 注册一个 `ApplicationContext`，如下示例所示：

[source,xml,indent=0,subs="verbatim,quotes"]
----
<context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml</param-value>
</context-param>

<listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
</listener>
----

此监听器会检查 `contextConfigLocation` 参数。如果该参数不存在，监听器将使用 `/WEB-INF/applicationContext.xml` 作为默认值。当参数存在时，监听器使用预定义的分隔符（逗号、分号和空白符）分割 `String`，并将这些值作为应用上下文的搜索位置。此外，还支持 Ant 风格的路径模式。例如 `/WEB-INF/{asterisk}Context.xml`（对于所有名称以 `Context.xml` 结尾且位于 `WEB-INF` 目录中的文件）和 `/WEB-INF/**/*Context.xml`（对于 `WEB-INF` 目录下的所有子目录中的文件）。



[[context-deploy-rar]]
=== 作为 Java EE RAR 文件部署 Spring `ApplicationContext`

可以将 Spring `ApplicationContext` 作为 RAR 文件进行部署，将上下文及其所需的所有 bean 类和库 JAR 封装在 Java EE RAR 部署单元中。这相当于在 Java EE 环境中托管的独立 `ApplicationContext`，能够访问 Java EE 服务器的设施。RAR 部署是部署无头 WAR 文件（即没有任何 HTTP 入口点，仅用于在 Java EE 环境中引导 Spring `ApplicationContext` 的 WAR 文件）的更自然的替代方案。

RAR 部署特别适合不需要 HTTP 入口点的应用上下文，而是仅包含消息端点和计划任务的上下文。此类上下文中的 Bean 可以使用应用服务器资源，如 JTA 事务管理器、JNDI 绑定的 JDBC `DataSource` 实例和 JMS `ConnectionFactory` 实例，还可以通过 Spring 的标准事务管理和 JNDI 以及 JMX 支持功能注册到平台的 JMX 服务器。应用组件还可以通过 Spring 的 `TaskExecutor` 抽象与应用服务器的 JCA `WorkManager` 交互。

有关 RAR 部署的配置详细信息，请参阅 {api-spring-framework}/jca/context/SpringContextResourceAdapter.html[`SpringContextResourceAdapter`] 类的 javadoc。

将 Spring ApplicationContext 作为 Java EE RAR 文件简单部署的步骤如下：

1. 将所有应用类打包到 RAR 文件中（RAR 文件是标准 JAR 文件，只是扩展名不同）。
2. 将所有必需的库 JAR 文件添加到 RAR 存档的根目录中。
3. 添加一个 `META-INF/ra.xml` 部署描述符（如 {api-spring-framework}/jca/context/SpringContextResourceAdapter.html[javadoc for `SpringContextResourceAdapter`] 所示），并添加相应的 Spring XML bean 定义文件（通常为 `META-INF/applicationContext.xml`）。
4. 将生成的 RAR 文件放入应用服务器的部署目录中。

NOTE: 此类 RAR 部署单元通常是自包含的。它们不会向外界（甚至同一应用程序的其他模块）公开组件。与基于 RAR 的 `ApplicationContext` 的交互通常通过与其他模块共享的 JMS 目标进行。例如，基于 RAR 的 `ApplicationContext` 可以调度一些任务或对文件系统中的新文件做出反应（或类似操作）。如果需要允许来自外部的同步访问，可以（例如）导出 RMI 端点，这些端点可以由同一台机器上的其他应用程序模块使用。



[[beans-beanfactory]]
== `BeanFactory`

`BeanFactory` API 为 Spring 的 IoC 功能提供了基础支持。它的具体合同大多用于与 Spring 的其他部分及相关的第三方框架集成，其 `DefaultListableBeanFactory` 实现是更高层次的 `GenericApplicationContext` 容器中的关键委托。

`BeanFactory` 及相关接口（如 `BeanFactoryAware`、`InitializingBean`、`DisposableBean`）是其他框架组件的重要集成点。由于不需要任何注解甚至反射，它们允许容器与其组件之间进行非常高效的交互。应用级别的 Bean 也可以使用相同的回调接口，但通常更倾向于通过注解或编程配置进行声明式依赖注入。

注意，核心的 `BeanFactory` API 级别及其 `DefaultListableBeanFactory` 实现不对配置格式或任何组件注解的使用做出假设。所有这些风格通过扩展（如 `XmlBeanDefinitionReader` 和 `AutowiredAnnotationBeanPostProcessor`）引入，并操作共享的 `BeanDefinition` 对象作为核心元数据表示。这就是 Spring 容器如此灵活和可扩展的本质。



[[context-introduction-ctx-vs-beanfactory]]
=== `BeanFactory` 还是 `ApplicationContext`？

本节解释了 `BeanFactory` 和 `ApplicationContext` 容器级别之间的差异及其对引导的影响。

除非有充分的理由不这样做，否则你应该使用 `ApplicationContext`，其中 `GenericApplicationContext` 及其子类 `AnnotationConfigApplicationContext` 是用于自定义引导的常用实现。这些是 Spring 核心容器的主要入口点，用于所有常见用途：加载配置文件、触发类路径扫描、以编程方式注册 bean 定义和注解类，以及（从 5.0 开始）注册函数式 bean 定义。

由于 `ApplicationContext` 包含 `BeanFactory` 的所有功能，因此通常推荐使用它，而不是单纯的 `BeanFactory`，除非在需要完全控制 bean 处理的场景中。在 `ApplicationContext` 中（例如 `GenericApplicationContext` 实现），根据约定（即通过 bean 名称或 bean 类型——特别是后处理器）检测到几种类型的 bean，而一个单纯的 `DefaultListableBeanFactory` 对任何特殊的 bean 都是无感知的。

对于许多扩展容器功能（如注解处理和 AOP 代理），<<beans-factory-extension-bpp, `BeanPostProcessor` 扩展点>> 是至关重要的。如果你只使用一个普通的 `DefaultListableBeanFactory`，默认情况下不会检测和激活此类后处理器。这种情况下，可能会让人感到困惑，因为你的 bean 配置实际上没有问题。相反，在这种情况下，容器需要通过额外的设置来完全引导。

以下表格列出了 `BeanFactory` 和 `ApplicationContext` 接口和实现所提供的功能。

[[context-introduction-ctx-vs-beanfactory-feature-matrix]]
.功能矩阵
[cols="50%,25%,25%"]
|===
| 功能 | `BeanFactory` | `ApplicationContext`

| Bean 实例化/装配
| 是
| 是

| 集成的生命周期管理
| 否
| 是

| 自动 `BeanPostProcessor` 注册
| 否
| 是

| 自动 `BeanFactoryPostProcessor` 注册
| 否
| 是

| 方便的 `MessageSource` 访问（用于国际化）
| 否
| 是

| 内置 `ApplicationEvent` 发布机制
| 否
| 是
|===

要在 `DefaultListableBeanFactory` 中显式注册一个 bean 后处理器，你需要以编程方式调用 `addBeanPostProcessor`，如下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
// 向工厂中填充 bean 定义

// 现在注册任何需要的 BeanPostProcessor 实例
factory.addBeanPostProcessor(new AutowiredAnnotationBeanPostProcessor());
factory.addBeanPostProcessor(new MyBeanPostProcessor());

// 现在开始使用工厂
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
val factory = DefaultListableBeanFactory()
// 向工厂中填充 bean 定义

// 现在注册任何需要的 BeanPostProcessor 实例
factory.addBeanPostProcessor(AutowiredAnnotationBeanPostProcessor())
factory.addBeanPostProcessor(MyBeanPostProcessor())

// 现在开始使用工厂
----

要将 `BeanFactoryPostProcessor` 应用到普通的 `DefaultListableBeanFactory`，你需要调用它的 `postProcessBeanFactory` 方法，如下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);
reader.loadBeanDefinitions(new FileSystemResource("beans.xml"));

// 从 Properties 文件中引入一些属性值
PropertySourcesPlaceholderConfigurer cfg = new PropertySourcesPlaceholderConfigurer();
cfg.setLocation(new FileSystemResource("jdbc.properties"));

// 现在实际进行替换
cfg.postProcessBeanFactory(factory);
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
val factory = DefaultListableBeanFactory()
val reader = XmlBeanDefinitionReader(factory)
reader.loadBeanDefinitions(FileSystemResource("beans.xml"))

// 从 Properties 文件中引入一些属性值
val cfg = PropertySourcesPlaceholderConfigurer()
cfg.setLocation(FileSystemResource("jdbc.properties"))

// 现在实际进行替换
cfg.postProcessBeanFactory(factory)
----

在这两种情况下，显式注册步骤都是不方便的，这也是在 Spring 支持的应用程序中 `ApplicationContext` 变体优于普通 `DefaultListableBeanFactory` 的原因，尤其是在典型企业环境中依赖 `BeanFactoryPostProcessor` 和 `BeanPostProcessor` 实例进行扩展容器功能时。

[NOTE]
====
`AnnotationConfigApplicationContext` 已注册了所有常见的注解后处理器，并可能通过配置注解（如 `@EnableTransactionManagement`）引入其他处理器。在 Spring 的注解配置模型的抽象级别，bean 后处理器的概念成为一个仅仅是内部容器的细节。
====

